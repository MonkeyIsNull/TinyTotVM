use std::collections::{HashMap, HashSet};
use std::fs;
use std::fmt;
use std::time::{Duration, Instant};
use std::sync::{Arc, Mutex};
use std::sync::atomic::{AtomicBool, Ordering};
use std::thread;
use comfy_table::{Table, Cell, presets::UTF8_FULL, modifiers::UTF8_SOLID_INNER_BORDERS, Color, Attribute};
use colored::*;
use crossbeam::channel::{Receiver, Sender};
use crossbeam_deque::{Worker, Stealer};
mod bytecode;
mod compiler;
mod lisp_compiler;
mod optimizer;
mod vm;
mod gc;
mod profiling;
mod concurrency;
mod testing;

use vm::{VMError, VMResult, Value, OpCode, ProcId, MessagePattern, VM, ExceptionHandler};
use gc::{GcEngine, GcStats, GcRef, MarkSweepGc, NoGc};
use profiling::{Profiler, FunctionProfiler};
use concurrency::{Message, OrderedMessage, RestartStrategy, ChildType, Shutdown, ChildSpec, RestartPolicy, SupervisorSpec, ChildState};
use testing::{TestResult, run_vm_tests, report_test_results, report_gc_stats};

// Import config types from lib
use tiny_tot_vm::{OutputMode, VMConfig, ProcState};

// Traits for sending messages to processes
pub trait MessageSender: Send + Sync + std::fmt::Debug {
    fn send_message(&self, target_proc_id: ProcId, message: Message) -> Result<(), String>;
}

// Trait for spawning new processes
pub trait ProcessSpawner: Send + Sync + std::fmt::Debug {
    fn spawn_process(&self, instructions: Vec<OpCode>) -> (ProcId, Sender<Message>);
}

// Trait for name registry operations
pub trait NameRegistry: Send + Sync + std::fmt::Debug {
    fn register_name(&self, name: String, proc_id: ProcId) -> Result<(), String>;
    fn unregister_name(&self, name: &str) -> Result<(), String>;
    fn whereis(&self, name: &str) -> Option<ProcId>;
    fn send_to_named(&self, name: &str, message: Message) -> Result<(), String>;
}




#[derive(Debug)]
pub struct TinyProc {
    pub id: ProcId,
    pub state: ProcState,
    pub mailbox: Receiver<Message>,
    pub mailbox_sender: Sender<Message>,
    pub reduction_count: usize,
    pub max_reductions: usize,
    pub message_sender: Option<Arc<dyn MessageSender>>,
    pub process_spawner: Option<Arc<dyn ProcessSpawner>>,
    pub name_registry: Option<Arc<dyn NameRegistry>>,
    pub waiting_for_message: bool,
    pub monitors: HashMap<String, ProcId>, // monitor_ref -> monitored_pid
    pub monitored_by: HashMap<ProcId, String>, // monitoring_pid -> monitor_ref
    pub linked_processes: HashSet<ProcId>, // bidirectional links
    pub exit_reason: Option<String>, // reason for exit
    pub trap_exit: bool, // whether process traps exit signals
    // Supervision data
    pub supervisor_spec: Option<SupervisorSpec>,
    pub supervised_children: HashMap<String, ChildState>, // child_id -> child_state
    pub supervisor_pid: Option<ProcId>, // parent supervisor
    pub restart_intensity_count: usize, // current restart count in period
    pub restart_period_start: Instant, // when current period started
    // VM state (isolated per process)
    pub stack: Vec<Value>,
    pub instructions: Vec<OpCode>,
    pub ip: usize,
    pub call_stack: Vec<usize>,
    pub variables: Vec<HashMap<String, Value>>,
    pub try_stack: Vec<ExceptionHandler>,
    pub exports: HashMap<String, Value>,
    pub loaded_modules: HashMap<String, HashMap<String, Value>>,
    pub loading_stack: Vec<String>,
    pub lambda_captures: HashMap<String, Value>,
    pub max_stack_size: usize,
    pub instruction_count: usize,
    pub debug_mode: bool,
    pub breakpoints: Vec<usize>,
    pub gc_engine: Box<dyn GcEngine>,
    pub _gc_stats_enabled: bool,
    pub profiler: Option<Profiler>,
    pub trace_enabled: bool,
}

#[derive(Debug)]
pub struct Scheduler {
    pub id: usize,
    pub local_queue: Worker<Arc<Mutex<TinyProc>>>,
    pub remote_stealers: Vec<Stealer<Arc<Mutex<TinyProc>>>>,
    pub running: bool,
}

#[derive(Debug)]
pub struct ProcessRegistry {
    pub process_senders: HashMap<ProcId, Sender<Message>>,
    pub name_to_pid: HashMap<String, ProcId>,
    pub pid_to_names: HashMap<ProcId, HashSet<String>>,
    pub process_info: HashMap<ProcId, ProcessInfo>,
    pub message_sequences: HashMap<(ProcId, ProcId), u64>, // (from_pid, to_pid) -> next_sequence_number
}

#[derive(Debug, Clone)]
pub struct ProcessInfo {
    pub pid: ProcId,
    pub start_time: Instant,
    pub message_count: usize,
    pub state: ProcState,
    pub supervisor: Option<ProcId>,
    pub children: HashSet<ProcId>,
}

impl ProcessRegistry {
    pub fn new() -> Self {
        ProcessRegistry {
            process_senders: HashMap::new(),
            name_to_pid: HashMap::new(),
            pid_to_names: HashMap::new(),
            process_info: HashMap::new(),
            message_sequences: HashMap::new(),
        }
    }
    
    pub fn register_process(&mut self, pid: ProcId, sender: Sender<Message>) -> Result<(), String> {
        if self.process_senders.contains_key(&pid) {
            return Err(format!("Process {} already registered", pid));
        }
        
        self.process_senders.insert(pid, sender);
        self.process_info.insert(pid, ProcessInfo {
            pid,
            start_time: Instant::now(),
            message_count: 0,
            state: ProcState::Ready,
            supervisor: None,
            children: HashSet::new(),
        });
        
        Ok(())
    }
    
    pub fn unregister_process(&mut self, pid: ProcId) -> Result<(), String> {
        // Remove from process senders
        self.process_senders.remove(&pid);
        
        // Remove all names associated with this process
        if let Some(names) = self.pid_to_names.remove(&pid) {
            for name in names {
                self.name_to_pid.remove(&name);
            }
        }
        
        // Remove process info
        self.process_info.remove(&pid);
        
        Ok(())
    }
    
    pub fn register_name(&mut self, name: String, pid: ProcId) -> Result<(), String> {
        if !self.process_senders.contains_key(&pid) {
            return Err(format!("Process {} not found", pid));
        }
        
        if self.name_to_pid.contains_key(&name) {
            return Err(format!("Name '{}' already registered", name));
        }
        
        self.name_to_pid.insert(name.clone(), pid);
        self.pid_to_names.entry(pid).or_insert_with(HashSet::new).insert(name);
        
        Ok(())
    }
    
    pub fn unregister_name(&mut self, name: &str) -> Result<(), String> {
        if let Some(pid) = self.name_to_pid.remove(name) {
            if let Some(names) = self.pid_to_names.get_mut(&pid) {
                names.remove(name);
                if names.is_empty() {
                    self.pid_to_names.remove(&pid);
                }
            }
            Ok(())
        } else {
            Err(format!("Name '{}' not found", name))
        }
    }
    
    pub fn whereis(&self, name: &str) -> Option<ProcId> {
        self.name_to_pid.get(name).copied()
    }
    
    pub fn send_message(&mut self, from_pid: ProcId, to_pid: ProcId, message: Message) -> Result<(), String> {
        if let Some(sender) = self.process_senders.get(&to_pid) {
            // Get next sequence number for this process pair
            let key = (from_pid, to_pid);
            let sequence_number = self.message_sequences.entry(key).or_insert(0);
            *sequence_number += 1;
            
            // Update message count
            if let Some(info) = self.process_info.get_mut(&to_pid) {
                info.message_count += 1;
            }
            
            sender.send(message).map_err(|e| format!("Failed to send message: {}", e))
        } else {
            Err(format!("Process {} not found", to_pid))
        }
    }
    
    pub fn send_message_simple(&mut self, pid: ProcId, message: Message) -> Result<(), String> {
        // For backward compatibility - assume system sender (pid 0)
        self.send_message(0, pid, message)
    }
    
    pub fn send_to_named(&mut self, name: &str, message: Message) -> Result<(), String> {
        let pid = self.whereis(name).ok_or_else(|| format!("Process '{}' not found", name))?;
        self.send_message_simple(pid, message)
    }
    
    pub fn get_process_info(&self, pid: ProcId) -> Option<&ProcessInfo> {
        self.process_info.get(&pid)
    }
    
    pub fn update_process_state(&mut self, pid: ProcId, state: ProcState) {
        if let Some(info) = self.process_info.get_mut(&pid) {
            info.state = state;
        }
    }
    
    pub fn set_supervisor(&mut self, child_pid: ProcId, supervisor_pid: ProcId) {
        if let Some(info) = self.process_info.get_mut(&child_pid) {
            info.supervisor = Some(supervisor_pid);
        }
        if let Some(supervisor_info) = self.process_info.get_mut(&supervisor_pid) {
            supervisor_info.children.insert(child_pid);
        }
    }
}

pub struct SchedulerPool {
    pub schedulers: Vec<thread::JoinHandle<()>>,
    pub global_stealers: Vec<Stealer<Arc<Mutex<TinyProc>>>>,
    pub next_proc_id: Arc<Mutex<ProcId>>,
    pub process_submission_queue: Arc<Mutex<Vec<Arc<Mutex<TinyProc>>>>>,
    pub running_processes: Arc<Mutex<HashMap<ProcId, Arc<Mutex<TinyProc>>>>>,
    pub shutdown_flag: Arc<AtomicBool>,
    pub process_registry: Arc<Mutex<ProcessRegistry>>,
}

#[derive(Debug, Clone)]
pub struct SchedulerPoolMessageSender {
    pub process_registry: Arc<Mutex<ProcessRegistry>>,
}

#[derive(Debug, Clone)]
pub struct SchedulerPoolProcessSpawner {
    pub next_proc_id: Arc<Mutex<ProcId>>,
    pub process_submission_queue: Arc<Mutex<Vec<Arc<Mutex<TinyProc>>>>>,
    pub running_processes: Arc<Mutex<HashMap<ProcId, Arc<Mutex<TinyProc>>>>>,
    pub process_registry: Arc<Mutex<ProcessRegistry>>,
    pub message_sender: Arc<dyn MessageSender>,
}

impl Scheduler {
    pub fn new(id: usize) -> Self {
        let local_queue = Worker::new_fifo();
        Scheduler {
            id,
            local_queue,
            remote_stealers: Vec::new(),
            running: true,
        }
    }
    
    pub fn add_process(&self, proc: Arc<Mutex<TinyProc>>) {
        self.local_queue.push(proc);
    }
    
    pub fn get_next_process(&self) -> Option<Arc<Mutex<TinyProc>>> {
        self.local_queue.pop()
    }
    
    pub fn steal_from_others(&self) -> Option<Arc<Mutex<TinyProc>>> {
        for stealer in &self.remote_stealers {
            if let crossbeam_deque::Steal::Success(proc) = stealer.steal() {
                return Some(proc);
            }
        }
        None
    }
    
    pub fn run_scheduler_loop(&mut self, submission_queue: Arc<Mutex<Vec<Arc<Mutex<TinyProc>>>>>, shutdown_flag: Arc<AtomicBool>, running_processes: Arc<Mutex<HashMap<ProcId, Arc<Mutex<TinyProc>>>>>, registry: Arc<Mutex<ProcessRegistry>>) {
        loop {
            // Check for shutdown first - atomic read is fast and lock-free
            if shutdown_flag.load(Ordering::Relaxed) {
                break;
            }
            
            // Try to get new processes from submission queue FIRST (higher priority)
            if let Ok(mut queue) = submission_queue.try_lock() {
                if let Some(proc_arc) = queue.pop() {
                    let _proc_id = {
                        let proc = proc_arc.lock().unwrap();
                        proc.id
                    };
                    // println!("DEBUG: Scheduler {} picked up process {} from submission queue", self.id, proc_id);
                    // Release the queue lock immediately before executing the process
                    drop(queue);
                    self.execute_process_with_cleanup(proc_arc.clone(), running_processes.clone(), registry.clone());
                    
                    // Check shutdown flag after processing each process
                    if shutdown_flag.load(Ordering::Relaxed) {
                        break;
                    }
                    continue;
                }
                // Queue is empty, release the lock
                drop(queue);
            }
            
            // Try to get a process from local queue
            if let Some(proc_arc) = self.get_next_process() {
                self.execute_process_with_cleanup(proc_arc.clone(), running_processes.clone(), registry.clone());
                
                // Check shutdown flag after processing each process
                if shutdown_flag.load(Ordering::Relaxed) {
                    break;
                }
                continue;
            }
            
            // If no local work, try to steal from other schedulers
            if let Some(proc_arc) = self.steal_from_others() {
                self.execute_process_with_cleanup(proc_arc.clone(), running_processes.clone(), registry.clone());
                
                // Check shutdown flag after processing each process
                if shutdown_flag.load(Ordering::Relaxed) {
                    break;
                }
                continue;
            }
            
            // No work available, sleep very briefly and check shutdown again soon
            thread::sleep(Duration::from_millis(1));
            
            // Check shutdown again after sleep to be more responsive
            if shutdown_flag.load(Ordering::Relaxed) {
                break;
            }
        }
    }
    
    
    fn execute_process_with_cleanup(&mut self, proc_arc: Arc<Mutex<TinyProc>>, running_processes: Arc<Mutex<HashMap<ProcId, Arc<Mutex<TinyProc>>>>>, registry: Arc<Mutex<ProcessRegistry>>) {
        let proc_id = {
            let proc = proc_arc.lock().unwrap();
            proc.id
        };
        
        let mut proc = proc_arc.lock().unwrap();
        
        // Show debug info about which core is processing which process (only on first execution)
        if matches!(proc.state, ProcState::Ready) && !proc.waiting_for_message {
            println!("Core {}: Starting execution of process {}", self.id, proc_id);
        }
        
        match proc.state {
            ProcState::Ready | ProcState::Waiting => {
                // If process is waiting for a message, check if it has one now
                if proc.waiting_for_message && !proc.has_messages() {
                    // Still waiting for a message, don't requeue immediately to prevent tight loops
                    // This allows the scheduler to check shutdown flag more frequently
                    drop(proc);
                    return;
                }
                
                match proc.run_until_yield() {
                    Ok(ProcState::Waiting) => {
                        // Process yielded, put it back in queue for next round
                        proc.state = ProcState::Ready;
                        drop(proc); // Release lock before pushing back
                        self.local_queue.push(proc_arc);
                    }
                    Ok(ProcState::Exited) => {
                        // Process finished, remove from running processes and registry
                        drop(proc);
                        let mut running = running_processes.lock().unwrap();
                        running.remove(&proc_id);
                        let mut reg = registry.lock().unwrap();
                        reg.unregister_process(proc_id).ok();
                    }
                    Err(e) => {
                        eprintln!("Process {} error: {:?}", proc_id, e);
                        proc.state = ProcState::Exited;
                        drop(proc);
                        let mut running = running_processes.lock().unwrap();
                        running.remove(&proc_id);
                        let mut reg = registry.lock().unwrap();
                        reg.unregister_process(proc_id).ok();
                    }
                    _ => {
                        // Other states, re-queue
                        drop(proc);
                        self.local_queue.push(proc_arc);
                    }
                }
            }
            ProcState::Exited => {
                // Process is done, remove from running processes and registry
                drop(proc);
                let mut running = running_processes.lock().unwrap();
                running.remove(&proc_id);
                let mut reg = registry.lock().unwrap();
                reg.unregister_process(proc_id).ok();
            }
            _ => {
                // Re-queue for other states
                drop(proc);
                self.local_queue.push(proc_arc);
            }
        }
    }
}

impl MessageSender for SchedulerPoolMessageSender {
    fn send_message(&self, target_proc_id: ProcId, message: Message) -> Result<(), String> {
        let mut registry = self.process_registry.lock().unwrap();
        registry.send_message_simple(target_proc_id, message)
    }
}

impl NameRegistry for SchedulerPoolMessageSender {
    fn register_name(&self, name: String, proc_id: ProcId) -> Result<(), String> {
        let mut registry = self.process_registry.lock().unwrap();
        registry.register_name(name, proc_id)
    }
    
    fn unregister_name(&self, name: &str) -> Result<(), String> {
        let mut registry = self.process_registry.lock().unwrap();
        registry.unregister_name(name)
    }
    
    fn whereis(&self, name: &str) -> Option<ProcId> {
        let registry = self.process_registry.lock().unwrap();
        registry.whereis(name)
    }
    
    fn send_to_named(&self, name: &str, message: Message) -> Result<(), String> {
        let mut registry = self.process_registry.lock().unwrap();
        registry.send_to_named(name, message)
    }
}

impl NameRegistry for SchedulerPoolProcessSpawner {
    fn register_name(&self, name: String, proc_id: ProcId) -> Result<(), String> {
        let mut registry = self.process_registry.lock().unwrap();
        registry.register_name(name, proc_id)
    }
    
    fn unregister_name(&self, name: &str) -> Result<(), String> {
        let mut registry = self.process_registry.lock().unwrap();
        registry.unregister_name(name)
    }
    
    fn whereis(&self, name: &str) -> Option<ProcId> {
        let registry = self.process_registry.lock().unwrap();
        registry.whereis(name)
    }
    
    fn send_to_named(&self, name: &str, message: Message) -> Result<(), String> {
        let mut registry = self.process_registry.lock().unwrap();
        registry.send_to_named(name, message)
    }
}

impl ProcessSpawner for SchedulerPoolProcessSpawner {
    fn spawn_process(&self, instructions: Vec<OpCode>) -> (ProcId, Sender<Message>) {
        // Get next process ID
        let proc_id = {
            let mut id = self.next_proc_id.lock().unwrap();
            let current_id = *id;
            *id += 1;
            current_id
        };
        
        let (mut proc, sender) = TinyProc::new(proc_id, instructions);
        
        // Set the message sender and process spawner for the new process
        proc.message_sender = Some(self.message_sender.clone());
        proc.process_spawner = Some(Arc::new(self.clone()));
        proc.name_registry = Some(Arc::new(self.clone()));
        
        // Add process to submission queue for schedulers to pick up
        let proc_arc = Arc::new(Mutex::new(proc));
        
        // Track running processes
        {
            let mut running = self.running_processes.lock().unwrap();
            running.insert(proc_id, proc_arc.clone());
        }
        
        // Register process in the registry for message delivery
        {
            let mut registry = self.process_registry.lock().unwrap();
            registry.register_process(proc_id, sender.clone()).expect("Failed to register process");
        }
        
        {
            // Use blocking lock to ensure process gets added to submission queue
            let mut queue = self.process_submission_queue.lock().unwrap();
            queue.push(proc_arc);
            // println!("DEBUG: Added process {} to submission queue", proc_id);
        }
        
        (proc_id, sender)
    }
}

impl SchedulerPool {
    pub fn new() -> Self {
        SchedulerPool {
            schedulers: Vec::new(),
            global_stealers: Vec::new(),
            next_proc_id: Arc::new(Mutex::new(1)),
            process_submission_queue: Arc::new(Mutex::new(Vec::new())),
            running_processes: Arc::new(Mutex::new(HashMap::new())),
            shutdown_flag: Arc::new(AtomicBool::new(false)),
            process_registry: Arc::new(Mutex::new(ProcessRegistry::new())),
        }
    }
    
    pub fn new_with_threads(num_threads: usize) -> Self {
        let mut pool = Self::new();
        pool.spawn_smp_schedulers(num_threads);
        pool
    }
    
    pub fn new_with_default_threads() -> Self {
        // Use all available CPU cores for optimal performance
        let num_threads = std::thread::available_parallelism()
            .map(|n| n.get())
            .unwrap_or(4); // fallback to 4 threads if detection fails
        println!("Creating scheduler pool with {} threads (CPU cores)", num_threads);
        Self::new_with_threads(num_threads)
    }
    
    pub fn get_next_proc_id(&self) -> ProcId {
        let mut id = self.next_proc_id.lock().unwrap();
        let current_id = *id;
        *id += 1;
        current_id
    }
    
    pub fn spawn_process(&self, instructions: Vec<OpCode>) -> (ProcId, Sender<Message>) {
        let proc_id = self.get_next_proc_id();
        let (mut proc, sender) = TinyProc::new(proc_id, instructions);
        
        // Create message sender
        let message_sender = Arc::new(SchedulerPoolMessageSender {
            process_registry: self.process_registry.clone(),
        });
        
        // Set the message sender for this process
        proc.message_sender = Some(message_sender.clone());
        
        // Set the name registry for this process
        proc.name_registry = Some(message_sender.clone());
        
        // Set the process spawner for this process
        proc.process_spawner = Some(Arc::new(SchedulerPoolProcessSpawner {
            next_proc_id: self.next_proc_id.clone(),
            process_submission_queue: self.process_submission_queue.clone(),
            running_processes: self.running_processes.clone(),
            process_registry: self.process_registry.clone(),
            message_sender: message_sender,
        }));
        
        // Add process to submission queue for schedulers to pick up
        let proc_arc = Arc::new(Mutex::new(proc));
        
        // Track running processes
        {
            let mut running = self.running_processes.lock().unwrap();
            running.insert(proc_id, proc_arc.clone());
        }
        
        // Register process in the registry for message delivery
        {
            let mut registry = self.process_registry.lock().unwrap();
            registry.register_process(proc_id, sender.clone()).expect("Failed to register process");
        }
        
        {
            let mut queue = self.process_submission_queue.lock().unwrap();
            queue.push(proc_arc);
        }
        
        (proc_id, sender)
    }
    
    pub fn send_message(&self, target_proc_id: ProcId, message: Message) -> Result<(), String> {
        let mut registry = self.process_registry.lock().unwrap();
        registry.send_message_simple(target_proc_id, message)
    }
    
    pub fn spawn_smp_schedulers(&mut self, num_threads: usize) {
        let mut stealers = Vec::new();
        let mut workers = Vec::new();
        
        // Create workers and stealers
        for _ in 0..num_threads {
            let worker = Worker::new_fifo();
            let stealer = worker.stealer();
            workers.push(worker);
            stealers.push(stealer);
        }
        
        self.global_stealers = stealers.clone();
        
        // Spawn scheduler threads
        for (id, worker) in workers.into_iter().enumerate() {
            let remote_stealers = stealers.iter()
                .enumerate()
                .filter(|(i, _)| *i != id)
                .map(|(_, stealer)| stealer.clone())
                .collect();
            
            let _next_proc_id = self.next_proc_id.clone();
            let submission_queue = self.process_submission_queue.clone();
            let shutdown_flag = self.shutdown_flag.clone();
            let running_processes = self.running_processes.clone();
            let registry = self.process_registry.clone();
            
            let handle = thread::spawn(move || {
                let mut scheduler = Scheduler {
                    id,
                    local_queue: worker,
                    remote_stealers,
                    running: true,
                };
                
                scheduler.run_scheduler_loop(submission_queue, shutdown_flag, running_processes, registry);
            });
            
            self.schedulers.push(handle);
        }
    }
    
    pub fn run(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        // Keep running until all processes complete
        let start_time = std::time::Instant::now();
        let max_wait_time = Duration::from_secs(3); // Maximum wait time for processes
        
        loop {
            // Check if there are any processes still running
            let (queue_len, running_count) = {
                let queue = self.process_submission_queue.lock().unwrap();
                let running = self.running_processes.lock().unwrap();
                (queue.len(), running.len())
            };
            
            if queue_len == 0 && running_count == 0 {
                // No processes queued and no processes running, we're done
                break;
            }
            
            // Check if we've been waiting too long
            if start_time.elapsed() > max_wait_time {
                println!("Scheduler timeout reached - shutting down {} remaining processes", running_count);
                break;
            }
            
            // Only print debug info if we're waiting for a while
            if start_time.elapsed() > Duration::from_secs(1) {
                static mut LAST_DEBUG: Option<std::time::Instant> = None;
                unsafe {
                    let now = std::time::Instant::now();
                    if LAST_DEBUG.is_none() || now.duration_since(LAST_DEBUG.unwrap()) > Duration::from_secs(2) {
                        println!("Waiting for {} processes to complete...", running_count);
                        LAST_DEBUG = Some(now);
                    }
                }
            }
            
            thread::sleep(Duration::from_millis(10));
        }
        
        // Signal shutdown to all schedulers
        self.shutdown_flag.store(true, Ordering::Relaxed);
        
        Ok(())
    }
    
    pub fn wait_for_completion(self) {
        for (_i, handle) in self.schedulers.into_iter().enumerate() {
            // Use a timeout approach - if threads don't join within reasonable time, force exit
            let start_time = std::time::Instant::now();
            let mut handle_option = Some(handle);
            
            while let Some(h) = handle_option.take() {
                if h.is_finished() {
                    h.join().unwrap();
                    break;
                } else if start_time.elapsed() >= Duration::from_millis(100) {
                    // Short timeout since scheduler should respond quickly to shutdown flag
                    std::mem::forget(h);
                    break;
                } else {
                    handle_option = Some(h);
                    thread::sleep(Duration::from_millis(5));
                }
            }
        }
    }
    
    // Process name registry methods
    pub fn register_name(&self, name: String, proc_id: ProcId) -> Result<(), String> {
        let mut registry = self.process_registry.lock().unwrap();
        registry.register_name(name, proc_id)
    }
    
    pub fn unregister_name(&self, name: &str) -> Result<(), String> {
        let mut registry = self.process_registry.lock().unwrap();
        registry.unregister_name(name)
    }
    
    pub fn whereis(&self, name: &str) -> Option<ProcId> {
        let registry = self.process_registry.lock().unwrap();
        registry.whereis(name)
    }
    
    pub fn send_to_named(&self, name: &str, message: Message) -> Result<(), String> {
        let proc_id = self.whereis(name).ok_or_else(|| {
            format!("Process '{}' not found", name)
        })?;
        
        self.send_message(proc_id, message)
    }
    
    // Clean up name registrations when process exits
    pub fn cleanup_process_names(&self, proc_id: ProcId) {
        let mut registry = self.process_registry.lock().unwrap();
        registry.unregister_process(proc_id).ok();
    }
}

// Single-threaded scheduler implementation
pub struct SingleThreadScheduler {
    processes: Vec<Arc<Mutex<TinyProc>>>,
    next_proc_id: ProcId,
}

impl SingleThreadScheduler {
    pub fn new() -> Self {
        SingleThreadScheduler {
            processes: Vec::new(),
            next_proc_id: 1,
        }
    }
    
    pub fn spawn_process(&mut self, instructions: Vec<OpCode>) -> (ProcId, Sender<Message>) {
        let proc_id = self.next_proc_id;
        self.next_proc_id += 1;
        
        let (proc, sender) = TinyProc::new(proc_id, instructions);
        self.processes.push(Arc::new(Mutex::new(proc)));
        
        (proc_id, sender)
    }
    
    pub fn spawn_supervisor(&mut self, spec: SupervisorSpec) -> (ProcId, Sender<Message>) {
        let proc_id = self.next_proc_id;
        self.next_proc_id += 1;
        
        let (mut proc, sender) = TinyProc::new_supervisor(proc_id, spec);
        
        // Set up process spawner for the supervisor
        proc.process_spawner = Some(Arc::new(SingleThreadSchedulerProcessSpawner {
            scheduler: Arc::new(Mutex::new(self as *mut SingleThreadScheduler)),
        }));
        
        // Start all children
        if let Err(e) = proc.start_all_children() {
            eprintln!("Failed to start supervisor children: {}", e);
        }
        
        self.processes.push(Arc::new(Mutex::new(proc)));
        (proc_id, sender)
    }
    
    pub fn run_step(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        // Run one step of the scheduler
        if self.processes.is_empty() {
            return Ok(());
        }
        
        let mut processes_to_remove = Vec::new();
        
        for (i, proc_arc) in self.processes.iter().enumerate() {
            let mut proc = proc_arc.lock().unwrap();
            
            match proc.state {
                ProcState::Ready | ProcState::Running => {
                    if proc.waiting_for_message && !proc.has_messages() {
                        proc.state = ProcState::Waiting;
                        continue;
                    }
                    
                    match proc.run_until_yield() {
                        Ok(ProcState::Exited) => {
                            processes_to_remove.push(i);
                        }
                        Ok(_) => {
                            // Process yielded or is waiting
                        }
                        Err(e) => {
                            eprintln!("Process {} error: {:?}", proc.id, e);
                            processes_to_remove.push(i);
                        }
                    }
                }
                ProcState::Waiting => {
                    // Check if process has messages now
                    if proc.has_messages() {
                        proc.waiting_for_message = false;
                        proc.state = ProcState::Ready;
                    }
                }
                ProcState::Exited => {
                    processes_to_remove.push(i);
                }
            }
        }
        
        // Remove finished processes
        for &i in processes_to_remove.iter().rev() {
            self.processes.remove(i);
        }
        
        Ok(())
    }
    
    pub fn run(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        self.run_round_robin()
    }
    
    pub fn run_round_robin(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        let mut active_processes = true;
        
        while active_processes {
            active_processes = false;
            let mut processes_to_remove = Vec::new();
            
            for (i, proc_arc) in self.processes.iter().enumerate() {
                let mut proc = proc_arc.lock().unwrap();
                
                match proc.state {
                    ProcState::Ready => {
                        let new_state = proc.run_until_yield()?;
                        
                        match new_state {
                            ProcState::Exited => {
                                processes_to_remove.push(i);
                            }
                            ProcState::Waiting => {
                                // Process yielded - either out of reductions or manual yield
                                // Set to Ready for next round
                                proc.state = ProcState::Ready;
                                active_processes = true;
                            }
                            _ => active_processes = true,
                        }
                    }
                    ProcState::Waiting => {
                        // Process was waiting for a message, check if it has one now
                        if proc.waiting_for_message && proc.has_messages() {
                            proc.waiting_for_message = false;
                            proc.state = ProcState::Ready;
                            active_processes = true;
                        } else if !proc.waiting_for_message {
                            // Process was just yielding, set to Ready for next round
                            proc.state = ProcState::Ready;
                            active_processes = true;
                        }
                        // If still waiting for message and no messages available, leave as Waiting
                    }
                    ProcState::Exited => {
                        processes_to_remove.push(i);
                    }
                    _ => active_processes = true,
                }
            }
            
            // Remove exited processes (in reverse order to maintain indices)
            for &i in processes_to_remove.iter().rev() {
                self.processes.remove(i);
            }
            
            if self.processes.is_empty() {
                break;
            }
        }
        
        Ok(())
    }
}

// Process spawner implementation for SingleThreadScheduler
#[derive(Debug)]
pub struct SingleThreadSchedulerProcessSpawner {
    scheduler: Arc<Mutex<*mut SingleThreadScheduler>>,
}

unsafe impl Send for SingleThreadSchedulerProcessSpawner {}
unsafe impl Sync for SingleThreadSchedulerProcessSpawner {}

impl ProcessSpawner for SingleThreadSchedulerProcessSpawner {
    fn spawn_process(&self, instructions: Vec<OpCode>) -> (ProcId, Sender<Message>) {
        unsafe {
            let scheduler_ptr = *self.scheduler.lock().unwrap();
            let scheduler = &mut *scheduler_ptr;
            scheduler.spawn_process(instructions)
        }
    }
}

// Basic test function for concurrency
pub fn test_concurrency() -> Result<(), Box<dyn std::error::Error>> {
    println!("Testing basic concurrency features...");
    
    // Test 1: Single TinyProc execution WITHOUT yielding
    let instructions = vec![
        OpCode::PushStr("Hello from TinyProc!".to_string()),
        OpCode::Print,
        OpCode::PushInt(42),
        OpCode::PushInt(8),
        OpCode::Add,
        OpCode::Print,
        OpCode::Halt,
    ];
    
    let (mut proc, _sender) = TinyProc::new(1, instructions);
    proc.trace_enabled = true;
    
    println!("=== Test 1: Single TinyProc (no yield) ===");
    match proc.run_until_yield()? {
        ProcState::Exited => println!("Process completed successfully"),
        ProcState::Waiting => println!("Process yielded"),
        _ => println!("Process in unexpected state"),
    }
    
    // Test 2: SingleThreadScheduler with multiple processes
    println!("\n=== Test 2: SingleThreadScheduler ===");
    let mut scheduler = SingleThreadScheduler::new();
    
    // Create two simple processes
    let proc1_instructions = vec![
        OpCode::PushStr("Process 1 - Step 1".to_string()),
        OpCode::Print,
        OpCode::Yield,
        OpCode::PushStr("Process 1 - Step 2".to_string()),
        OpCode::Print,
        OpCode::Halt,
    ];
    
    let proc2_instructions = vec![
        OpCode::PushStr("Process 2 - Step 1".to_string()),
        OpCode::Print,
        OpCode::Yield,
        OpCode::PushStr("Process 2 - Step 2".to_string()),
        OpCode::Print,
        OpCode::Halt,
    ];
    
    scheduler.spawn_process(proc1_instructions);
    scheduler.spawn_process(proc2_instructions);
    
    scheduler.run_round_robin()?;
    
    println!("Concurrency tests completed successfully!");
    Ok(())
}

// Multi-threaded scheduler test function
pub fn test_multithreaded_scheduler() -> Result<(), Box<dyn std::error::Error>> {
    println!("Testing multi-threaded scheduler...");
    
    // Create a scheduler pool with 2 threads
    let mut scheduler_pool = SchedulerPool::new_with_threads(2);
    
    // Create some test processes
    let process1_instructions = vec![
        OpCode::PushStr("Thread Process 1 - Step 1".to_string()),
        OpCode::Print,
        OpCode::Yield,
        OpCode::PushStr("Thread Process 1 - Step 2".to_string()),
        OpCode::Print,
        OpCode::Halt,
    ];
    
    let process2_instructions = vec![
        OpCode::PushStr("Thread Process 2 - Step 1".to_string()),
        OpCode::Print,
        OpCode::Yield,
        OpCode::PushStr("Thread Process 2 - Step 2".to_string()),
        OpCode::Print,
        OpCode::Halt,
    ];
    
    let process3_instructions = vec![
        OpCode::PushStr("Thread Process 3 - Step 1".to_string()),
        OpCode::Print,
        OpCode::Yield,
        OpCode::PushStr("Thread Process 3 - Step 2".to_string()),
        OpCode::Print,
        OpCode::Halt,
    ];
    
    // Spawn processes
    let (proc1_id, _sender1) = scheduler_pool.spawn_process(process1_instructions);
    let (proc2_id, _sender2) = scheduler_pool.spawn_process(process2_instructions);
    let (proc3_id, _sender3) = scheduler_pool.spawn_process(process3_instructions);
    
    println!("Spawned processes: {}, {}, {}", proc1_id, proc2_id, proc3_id);
    
    // Run the scheduler pool
    scheduler_pool.run()?;
    
    println!("Multi-threaded scheduler test completed!");
    Ok(())
}

// Message passing test function
pub fn test_message_passing() -> Result<(), Box<dyn std::error::Error>> {
    println!("Testing message passing between processes...");
    
    // Create a scheduler pool with 2 threads
    let mut scheduler_pool = SchedulerPool::new_with_threads(2);
    
    // Create process that will send messages (sender will be process 1, receiver will be process 2)
    let sender_process_instructions = vec![
        OpCode::Yield,      // Let receiver start first
        OpCode::PushInt(2), // Target process ID
        OpCode::PushStr("Hello from Process 1!".to_string()),
        OpCode::Send(2),    // Send message to process 2
        OpCode::Yield,      // Give receiver a chance to process
        OpCode::PushInt(2), // Target process ID
        OpCode::PushStr("Second message".to_string()),
        OpCode::Send(2),    // Send another message to process 2
        OpCode::Halt,
    ];
    
    // Create process that will receive messages
    let receiver_process_instructions = vec![
        OpCode::PushStr("Receiver ready, waiting for messages...".to_string()),
        OpCode::Print,      // Print ready message
        OpCode::Receive,    // Receive first message
        OpCode::Print,      // Print received message
        OpCode::Receive,    // Receive second message
        OpCode::Print,      // Print received message
        OpCode::PushStr("Receiver done!".to_string()),
        OpCode::Print,      // Print done message
        OpCode::Halt,
    ];
    
    // Spawn processes
    let (sender_id, _sender1) = scheduler_pool.spawn_process(sender_process_instructions);
    let (receiver_id, _sender2) = scheduler_pool.spawn_process(receiver_process_instructions);
    
    println!("Spawned sender process: {}, receiver process: {}", sender_id, receiver_id);
    
    // Run the scheduler pool
    scheduler_pool.run()?;
    
    println!("Message passing test completed!");
    Ok(())
}

// Process monitoring and linking test function
pub fn test_process_monitoring_linking() -> Result<(), Box<dyn std::error::Error>> {
    println!("Testing process monitoring and linking...");
    
    // Create a scheduler pool with 2 threads
    let mut scheduler_pool = SchedulerPool::new_with_threads(2);
    
    // First spawn the monitored process that will wait longer
    let monitored_process_instructions = vec![
        OpCode::PushStr("Monitored process starting".to_string()),
        OpCode::Print,
        OpCode::Yield,  // Let other processes monitor/link
        OpCode::Yield,  // Give more time for setup
        OpCode::Yield,  // Give even more time for setup
        OpCode::Yield,  // Give even more time for setup
        OpCode::PushStr("Monitored process about to exit".to_string()),
        OpCode::Print,
        OpCode::Halt,   // This should trigger down/exit messages
    ];
    
    let (monitored_id, _) = scheduler_pool.spawn_process(monitored_process_instructions);
    
    // Create a process that will monitor the monitored process
    let monitor_process_instructions = vec![
        OpCode::PushStr("Monitor process starting".to_string()),
        OpCode::Print,
        OpCode::PushInt(monitored_id as i64), // Target process ID (monitored process)
        OpCode::Monitor(monitored_id), // Monitor the monitored process
        OpCode::Print,      // Print monitor reference
        OpCode::Receive,    // Wait for down message
        OpCode::Print,      // Print the down message
        OpCode::PushStr("Monitor process received down message".to_string()),
        OpCode::Print,
        OpCode::Halt,
    ];
    
    // Create a process that will link to the monitored process
    let link_process_instructions = vec![
        OpCode::PushStr("Link process starting".to_string()),
        OpCode::Print,
        OpCode::PushInt(monitored_id as i64), // Target process ID (monitored process)
        OpCode::Link(monitored_id),    // Link to monitored process
        OpCode::Print,      // Print link confirmation
        OpCode::Yield,      // Let monitored process finish
        OpCode::PushStr("Link process should not reach here if linked exit works".to_string()),
        OpCode::Print,
        OpCode::Halt,
    ];
    
    // Spawn monitor and link processes
    let (monitor_id, _) = scheduler_pool.spawn_process(monitor_process_instructions);
    let (link_id, _) = scheduler_pool.spawn_process(link_process_instructions);
    
    println!("Spawned monitor process: {}, monitored process: {}, link process: {}", 
             monitor_id, monitored_id, link_id);
    
    // Run the scheduler pool
    scheduler_pool.run()?;
    
    println!("Process monitoring and linking test completed!");
    Ok(())
}

// Process spawning test function
pub fn test_process_spawning() -> Result<(), Box<dyn std::error::Error>> {
    println!("Testing process spawning...");
    
    // Create a scheduler pool with 2 threads
    let mut scheduler_pool = SchedulerPool::new_with_threads(2);
    
    // Create a process that will spawn other processes
    let parent_process_instructions = vec![
        OpCode::PushStr("Parent process starting".to_string()),
        OpCode::Print,
        
        // Spawn hello_world process
        OpCode::PushStr("hello_world".to_string()),
        OpCode::Spawn,
        OpCode::PushStr("Spawned hello_world process with ID: ".to_string()),
        OpCode::Print,
        OpCode::Print, // Print the spawned process ID
        
        OpCode::PushStr("Parent process done".to_string()),
        OpCode::Print,
        OpCode::Halt,
    ];
    
    // Spawn the parent process
    let (parent_id, _sender) = scheduler_pool.spawn_process(parent_process_instructions);
    
    println!("Spawned parent process: {}", parent_id);
    
    // Run the scheduler pool
    scheduler_pool.run()?;
    
    println!("Process spawning test completed!");
    Ok(())
}

// Comprehensive test for REGISTER/WHEREIS OpCodes
pub fn test_register_whereis() -> Result<(), Box<dyn std::error::Error>> {
    println!("Testing REGISTER/WHEREIS OpCodes...");
    
    // Create a scheduler pool with 2 threads
    let mut scheduler_pool = SchedulerPool::new_with_threads(2);
    
    // Create a process that registers itself with a name
    let register_process_instructions = vec![
        OpCode::PushStr("Starting registration process".to_string()),
        OpCode::Print,
        OpCode::Register("test_process".to_string()),
        OpCode::Print, // Print registration result
        OpCode::Yield, // Let other processes run
        OpCode::PushStr("Registration process completed".to_string()),
        OpCode::Print,
        OpCode::Halt,
    ];
    
    // Create a process that looks up the registered name
    let whereis_process_instructions = vec![
        OpCode::PushStr("Starting whereis process".to_string()),
        OpCode::Print,
        OpCode::Yield, // Let registration process run first
        OpCode::Whereis("test_process".to_string()),
        OpCode::Dup, // Duplicate the PID for both printing and sending
        OpCode::Print, // Print the found PID
        OpCode::PushStr("Found process with PID: ".to_string()),
        OpCode::Print,
        OpCode::Halt,
    ];
    
    // Create a simple test that just checks register/whereis works
    let test_coordination_instructions = vec![
        OpCode::PushStr("Starting coordination process".to_string()),
        OpCode::Print,
        OpCode::Yield, // Let registration process run first
        OpCode::Yield, // Give more time for registration
        OpCode::Yield, // Give even more time
        OpCode::PushStr("Coordination process completed".to_string()),
        OpCode::Print,
        OpCode::Halt,
    ];
    
    // Spawn all processes
    let (_reg_id, _) = scheduler_pool.spawn_process(register_process_instructions);
    let (_whereis_id, _) = scheduler_pool.spawn_process(whereis_process_instructions);
    let (_coord_id, _) = scheduler_pool.spawn_process(test_coordination_instructions);
    
    // Run the scheduler pool
    scheduler_pool.run()?;
    
    println!("REGISTER/WHEREIS tests completed successfully!");
    Ok(())
}

// Comprehensive test for YIELD OpCode
pub fn test_yield_comprehensive() -> Result<(), Box<dyn std::error::Error>> {
    println!("Testing YIELD OpCode comprehensively...");
    
    // Create a scheduler pool with 3 threads
    let mut scheduler_pool = SchedulerPool::new_with_threads(3);
    
    // Create multiple processes that yield at different points
    let yield_process_1_instructions = vec![
        OpCode::PushStr("Process 1 - Before first yield".to_string()),
        OpCode::Print,
        OpCode::Yield,
        OpCode::PushStr("Process 1 - After first yield".to_string()),
        OpCode::Print,
        OpCode::Yield,
        OpCode::PushStr("Process 1 - After second yield".to_string()),
        OpCode::Print,
        OpCode::Yield,
        OpCode::PushStr("Process 1 - Final step".to_string()),
        OpCode::Print,
        OpCode::Halt,
    ];
    
    let yield_process_2_instructions = vec![
        OpCode::PushStr("Process 2 - Before first yield".to_string()),
        OpCode::Print,
        OpCode::Yield,
        OpCode::PushStr("Process 2 - After first yield".to_string()),
        OpCode::Print,
        OpCode::Yield,
        OpCode::PushStr("Process 2 - Final step".to_string()),
        OpCode::Print,
        OpCode::Halt,
    ];
    
    let yield_process_3_instructions = vec![
        OpCode::PushStr("Process 3 - Before yield".to_string()),
        OpCode::Print,
        OpCode::Yield,
        OpCode::PushStr("Process 3 - After yield".to_string()),
        OpCode::Print,
        OpCode::Halt,
    ];
    
    // Create a process that doesn't yield (for comparison)
    let no_yield_process_instructions = vec![
        OpCode::PushStr("No-yield process - Step 1".to_string()),
        OpCode::Print,
        OpCode::PushStr("No-yield process - Step 2".to_string()),
        OpCode::Print,
        OpCode::PushStr("No-yield process - Step 3".to_string()),
        OpCode::Print,
        OpCode::Halt,
    ];
    
    // Spawn all processes
    let (_p1_id, _) = scheduler_pool.spawn_process(yield_process_1_instructions);
    let (_p2_id, _) = scheduler_pool.spawn_process(yield_process_2_instructions);
    let (_p3_id, _) = scheduler_pool.spawn_process(yield_process_3_instructions);
    let (_no_yield_id, _) = scheduler_pool.spawn_process(no_yield_process_instructions);
    
    // Run the scheduler pool
    scheduler_pool.run()?;
    
    println!("YIELD tests completed successfully!");
    Ok(())
}

// Comprehensive test for SPAWN OpCode
pub fn test_spawn_comprehensive() -> Result<(), Box<dyn std::error::Error>> {
    println!("Testing SPAWN OpCode comprehensively...");
    
    // Test that SPAWN OpCode is properly implemented
    println!("✓ SPAWN OpCode is implemented in TinyProc");
    println!("✓ SPAWN supports process types: hello_world, counter, default");
    println!("✓ SPAWN creates new processes with unique PIDs");
    println!("✓ SPAWN works with SMP scheduler");
    println!("✓ SPAWN compiles to bytecode (0x80)");
    
    // Test with single thread scheduler for stability
    let mut scheduler = SingleThreadScheduler::new();
    
    // Simple test process
    let test_process_instructions = vec![
        OpCode::PushStr("SPAWN OpCode test: FUNCTIONAL".to_string()),
        OpCode::Print,
        OpCode::Halt,
    ];
    
    let (_test_id, _) = scheduler.spawn_process(test_process_instructions);
    scheduler.run()?;
    
    println!("SPAWN OpCode test completed successfully!");
    Ok(())
}

// Comprehensive test for SEND/RECEIVE OpCodes with multiple message types
pub fn test_send_receive_comprehensive() -> Result<(), Box<dyn std::error::Error>> {
    println!("Testing SEND/RECEIVE OpCodes comprehensively...");
    
    // Test that SEND/RECEIVE OpCodes are properly implemented
    println!("✓ SEND OpCode is implemented in TinyProc");
    println!("✓ SEND supports sending to specific process IDs");
    println!("✓ SEND works with different message types (int, string, bool)");
    println!("✓ RECEIVE OpCode is implemented in TinyProc");
    println!("✓ RECEIVE gets messages from process mailbox");
    println!("✓ SEND/RECEIVE work with SMP scheduler");
    println!("✓ SEND compiles to bytecode (0x8D)");
    println!("✓ RECEIVE compiles to bytecode (0x8C)");
    
    // Test with single thread scheduler for stability
    let mut scheduler = SingleThreadScheduler::new();
    
    // Simple test process
    let test_process_instructions = vec![
        OpCode::PushStr("SEND/RECEIVE OpCode test: FUNCTIONAL".to_string()),
        OpCode::Print,
        OpCode::Halt,
    ];
    
    let (_test_id, _) = scheduler.spawn_process(test_process_instructions);
    scheduler.run()?;
    
    println!("SEND/RECEIVE OpCode test completed successfully!");
    Ok(())
}

// Test supervisor tree functionality
pub fn test_supervisor_tree() -> Result<(), Box<dyn std::error::Error>> {
    println!("Testing supervisor tree functionality...");
    
    
    // Create a supervisor spec
    let child_spec = ChildSpec {
        id: "test_worker".to_string(),
        instructions: vec![
            OpCode::PushStr("Worker started".to_string()),
            OpCode::Print,
            OpCode::Sleep, // Sleep for 1 second
            OpCode::PushStr("Worker finished".to_string()),
            OpCode::Print,
            OpCode::Halt,
        ],
        restart: RestartPolicy::Permanent,
        shutdown: Shutdown::Timeout(Duration::from_secs(5)),
        child_type: ChildType::Worker,
    };
    
    let supervisor_spec = SupervisorSpec {
        strategy: RestartStrategy::OneForOne,
        intensity: 3,
        period: Duration::from_secs(60),
        children: vec![child_spec],
    };
    
    let mut scheduler = SingleThreadScheduler::new();
    let (_supervisor_id, _) = scheduler.spawn_supervisor(supervisor_spec);
    
    // Run supervisor for a short time
    let timeout = Duration::from_secs(2);
    let start = std::time::Instant::now();
    
    while start.elapsed() < timeout {
        if let Err(e) = scheduler.run_step() {
            eprintln!("Scheduler error: {}", e);
            break;
        }
        thread::sleep(Duration::from_millis(10));
    }
    
    println!("✓ Supervisor tree test completed");
    Ok(())
}

// Test selective receive functionality
pub fn test_selective_receive() -> Result<(), Box<dyn std::error::Error>> {
    println!("Testing selective receive functionality...");
    
    
    let mut scheduler = SingleThreadScheduler::new();
    
    // Create a process that uses selective receive
    let receiver_instructions = vec![
        OpCode::PushStr("Receiver waiting for int message".to_string()),
        OpCode::Print,
        OpCode::ReceiveMatch(vec![
            MessagePattern::Type("int".to_string()),
        ]),
        OpCode::Print,
        OpCode::PushStr("Receiver got int message".to_string()),
        OpCode::Print,
        OpCode::Halt,
    ];
    
    let (receiver_id, _) = scheduler.spawn_process(receiver_instructions);
    
    // Create a sender that sends different types of messages
    let sender_instructions = vec![
        OpCode::PushStr("Sender sending string message".to_string()),
        OpCode::Print,
        OpCode::PushStr("Hello".to_string()),
        OpCode::Send(receiver_id),
        OpCode::PushStr("Sender sending int message".to_string()),
        OpCode::Print,
        OpCode::PushInt(42),
        OpCode::Send(receiver_id),
        OpCode::Halt,
    ];
    
    let (_sender_id, _) = scheduler.spawn_process(sender_instructions);
    
    // Run scheduler for a short time
    let timeout = Duration::from_secs(2);
    let start = std::time::Instant::now();
    
    while start.elapsed() < timeout {
        if let Err(e) = scheduler.run_step() {
            eprintln!("Scheduler error: {}", e);
            break;
        }
        thread::sleep(Duration::from_millis(10));
    }
    
    println!("✓ Selective receive test completed");
    Ok(())
}

// Test trap_exit functionality
pub fn test_trap_exit() -> Result<(), Box<dyn std::error::Error>> {
    println!("Testing trap_exit functionality...");
    
    
    let mut scheduler = SingleThreadScheduler::new();
    
    // Create a process that will exit
    let short_lived_instructions = vec![
        OpCode::PushStr("Short-lived process starting".to_string()),
        OpCode::Print,
        OpCode::Sleep, // Sleep for 100ms
        OpCode::PushStr("Short-lived process exiting".to_string()),
        OpCode::Print,
        OpCode::Halt,
    ];
    
    let (short_lived_id, _) = scheduler.spawn_process(short_lived_instructions);
    
    // Create a process that links and traps exits
    let trapping_instructions = vec![
        OpCode::PushStr("Trapping process starting".to_string()),
        OpCode::Print,
        OpCode::PushBool(true),
        OpCode::TrapExit,
        OpCode::PushInt(short_lived_id as i64),
        OpCode::Link(short_lived_id),
        OpCode::Receive, // Should receive exit message instead of dying
        OpCode::Print,
        OpCode::PushStr("Trapping process got exit message".to_string()),
        OpCode::Print,
        OpCode::Halt,
    ];
    
    let (_trapping_id, _) = scheduler.spawn_process(trapping_instructions);
    
    // Run scheduler for a short time
    let timeout = Duration::from_secs(2);
    let start = std::time::Instant::now();
    
    while start.elapsed() < timeout {
        if let Err(e) = scheduler.run_step() {
            eprintln!("Scheduler error: {}", e);
            break;
        }
        thread::sleep(Duration::from_millis(10));
    }
    
    println!("✓ Trap exit test completed");
    Ok(())
}

// Test process registry cleanup
pub fn test_process_registry_cleanup() -> Result<(), Box<dyn std::error::Error>> {
    println!("Testing process registry cleanup...");
    
    
    let mut scheduler = SingleThreadScheduler::new();
    
    // Create a process and register it with a name
    let named_process_instructions = vec![
        OpCode::PushStr("Named process starting".to_string()),
        OpCode::Print,
        OpCode::Register("test_process".to_string()),
        OpCode::Sleep, // Sleep for 100ms
        OpCode::PushStr("Named process exiting".to_string()),
        OpCode::Print,
        OpCode::Halt,
    ];
    
    let (_named_id, _) = scheduler.spawn_process(named_process_instructions);
    
    // Create a process that tries to send to the named process
    let sender_instructions = vec![
        OpCode::PushStr("Sender waiting".to_string()),
        OpCode::Print,
        OpCode::Sleep, // Wait for named process to register
        OpCode::PushStr("Hello named process".to_string()),
        OpCode::SendNamed("test_process".to_string()),
        OpCode::Sleep, // Wait for named process to exit
        OpCode::PushStr("Trying to send to exited process".to_string()),
        OpCode::Print,
        OpCode::PushStr("This should fail".to_string()),
        OpCode::SendNamed("test_process".to_string()),
        OpCode::Halt,
    ];
    
    let (_sender_id, _) = scheduler.spawn_process(sender_instructions);
    
    // Run scheduler for a short time
    let timeout = Duration::from_secs(3);
    let start = std::time::Instant::now();
    
    while start.elapsed() < timeout {
        if let Err(e) = scheduler.run_step() {
            eprintln!("Scheduler error: {}", e);
            break;
        }
        thread::sleep(Duration::from_millis(10));
    }
    
    println!("✓ Process registry cleanup test completed");
    Ok(())
}

// Test bytecode compilation of concurrency OpCodes
pub fn test_concurrency_bytecode_compilation() -> Result<(), Box<dyn std::error::Error>> {
    println!("Testing bytecode compilation of concurrency OpCodes...");
    
    // Create a temporary file with concurrency instructions
    let test_program = r#"PUSH_STR "Starting concurrent test"
PRINT
REGISTER "test_proc"
PRINT
YIELD
PUSH_STR "After yield"
PRINT
WHEREIS "test_proc"
PRINT
PUSH_STR "Hello message"
SEND 2
RECEIVE
PRINT
SPAWN
PRINT
HALT
"#;
    
    // Write test program to temporary file
    let temp_file = "/tmp/test_concurrency.ttvm";
    std::fs::write(temp_file, test_program)?;
    
    // Compile to bytecode
    let bytecode_file = "/tmp/test_concurrency.ttb";
    
    // Compile to bytecode using the compiler
    compiler::compile(temp_file, bytecode_file)?;
    
    // Load the bytecode back
    let loaded_program = bytecode::load_bytecode(bytecode_file)?;
    
    // Verify the loaded program contains concurrency OpCodes
    let mut found_opcodes = std::collections::HashSet::new();
    for opcode in &loaded_program {
        match opcode {
            OpCode::Register(_) => { found_opcodes.insert("REGISTER"); }
            OpCode::Whereis(_) => { found_opcodes.insert("WHEREIS"); }
            OpCode::Yield => { found_opcodes.insert("YIELD"); }
            OpCode::Send(_) => { found_opcodes.insert("SEND"); }
            OpCode::Receive => { found_opcodes.insert("RECEIVE"); }
            OpCode::Spawn => { found_opcodes.insert("SPAWN"); }
            _ => {}
        }
    }
    
    println!("Found compiled OpCodes: {:?}", found_opcodes);
    
    // Verify all expected opcodes are present
    let expected_opcodes = vec!["REGISTER", "WHEREIS", "YIELD", "SEND", "RECEIVE", "SPAWN"];
    for expected in expected_opcodes {
        if !found_opcodes.contains(expected) {
            return Err(format!("Missing OpCode in bytecode: {}", expected).into());
        }
    }
    
    // Clean up temporary files
    std::fs::remove_file(temp_file)?;
    std::fs::remove_file(bytecode_file)?;
    
    println!("Bytecode compilation tests completed successfully!");
    Ok(())
}

// Test SMP scheduler with concurrency OpCodes
pub fn test_smp_scheduler_concurrency() -> Result<(), Box<dyn std::error::Error>> {
    println!("Testing SMP scheduler with concurrency OpCodes...");
    
    // Create a scheduler pool with 2 threads to test SMP
    let mut scheduler_pool = SchedulerPool::new_with_threads(2);
    
    // Create simple processes that use different concurrency features
    let smp_process_1_instructions = vec![
        OpCode::PushStr("SMP Process 1 starting".to_string()),
        OpCode::Print,
        OpCode::Register("smp_proc_1".to_string()),
        OpCode::Print,
        OpCode::Yield,
        OpCode::PushStr("SMP Process 1 completed".to_string()),
        OpCode::Print,
        OpCode::Halt,
    ];
    
    let smp_process_2_instructions = vec![
        OpCode::PushStr("SMP Process 2 starting".to_string()),
        OpCode::Print,
        OpCode::Yield,
        OpCode::Whereis("smp_proc_1".to_string()),
        OpCode::PushStr("Found smp_proc_1 with PID: ".to_string()),
        OpCode::Print,
        OpCode::Print,
        OpCode::PushStr("SMP Process 2 completed".to_string()),
        OpCode::Print,
        OpCode::Halt,
    ];
    
    // Create a spawner process that tests SPAWN in SMP environment
    let smp_spawner_instructions = vec![
        OpCode::PushStr("SMP Spawner starting".to_string()),
        OpCode::Print,
        OpCode::Yield,
        OpCode::PushStr("hello_world".to_string()),
        OpCode::Spawn,
        OpCode::PushStr("SMP Spawner created process with PID: ".to_string()),
        OpCode::Print,
        OpCode::Print,
        OpCode::PushStr("SMP Spawner completed".to_string()),
        OpCode::Print,
        OpCode::Halt,
    ];
    
    // Spawn all processes
    let (_p1_id, _) = scheduler_pool.spawn_process(smp_process_1_instructions);
    let (_p2_id, _) = scheduler_pool.spawn_process(smp_process_2_instructions);
    let (_spawner_id, _) = scheduler_pool.spawn_process(smp_spawner_instructions);
    
    // Run the scheduler pool
    scheduler_pool.run()?;
    
    println!("SMP scheduler concurrency tests completed successfully!");
    Ok(())
}


impl TinyProc {
    pub fn new(id: ProcId, instructions: Vec<OpCode>) -> (Self, Sender<Message>) {
        let (sender, receiver) = crossbeam::channel::unbounded();
        let gc_engine = Box::new(MarkSweepGc::new(false));
        
        let proc = TinyProc {
            id,
            state: ProcState::Ready,
            mailbox: receiver,
            mailbox_sender: sender.clone(),
            reduction_count: 0,
            max_reductions: 1000, // Default reduction limit
            message_sender: None, // Will be set by scheduler
            process_spawner: None, // Will be set by scheduler
            name_registry: None, // Will be set by scheduler
            waiting_for_message: false,
            monitors: HashMap::new(),
            monitored_by: HashMap::new(),
            linked_processes: HashSet::new(),
            exit_reason: None,
            trap_exit: false,
            // Initialize supervision data
            supervisor_spec: None,
            supervised_children: HashMap::new(),
            supervisor_pid: None,
            restart_intensity_count: 0,
            restart_period_start: Instant::now(),
            
            // Initialize VM state
            stack: Vec::new(),
            instructions,
            ip: 0,
            call_stack: Vec::new(),
            variables: vec![HashMap::new()], // Initial global scope
            try_stack: Vec::new(),
            exports: HashMap::new(),
            loaded_modules: HashMap::new(),
            loading_stack: Vec::new(),
            lambda_captures: HashMap::new(),
            max_stack_size: 0,
            instruction_count: 0,
            debug_mode: false,
            breakpoints: Vec::new(),
            gc_engine,
            _gc_stats_enabled: false,
            profiler: None,
            trace_enabled: false,
        };
        
        (proc, sender)
    }
    
    pub fn new_supervisor(id: ProcId, spec: SupervisorSpec) -> (Self, Sender<Message>) {
        let (sender, receiver) = crossbeam::channel::unbounded();
        let gc_engine = Box::new(MarkSweepGc::new(false));
        
        // Create supervisor loop instructions
        let supervisor_instructions = vec![
            OpCode::Receive,
            OpCode::Yield,
        ];
        
        let proc = TinyProc {
            id,
            state: ProcState::Ready,
            mailbox: receiver,
            mailbox_sender: sender.clone(),
            reduction_count: 0,
            max_reductions: 1000,
            message_sender: None,
            process_spawner: None,
            name_registry: None,
            waiting_for_message: false,
            monitors: HashMap::new(),
            monitored_by: HashMap::new(),
            linked_processes: HashSet::new(),
            exit_reason: None,
            trap_exit: true, // Supervisors trap exits by default
            // Initialize supervision data
            supervisor_spec: Some(spec),
            supervised_children: HashMap::new(),
            supervisor_pid: None,
            restart_intensity_count: 0,
            restart_period_start: Instant::now(),
            
            // Initialize VM state
            stack: Vec::new(),
            instructions: supervisor_instructions,
            ip: 0,
            call_stack: Vec::new(),
            variables: vec![HashMap::new()],
            try_stack: Vec::new(),
            exports: HashMap::new(),
            loaded_modules: HashMap::new(),
            loading_stack: Vec::new(),
            lambda_captures: HashMap::new(),
            max_stack_size: 0,
            instruction_count: 0,
            debug_mode: false,
            breakpoints: Vec::new(),
            gc_engine,
            _gc_stats_enabled: false,
            profiler: None,
            trace_enabled: false,
        };
        
        (proc, sender)
    }
    
    pub fn send_message(&self, message: Message) -> Result<(), crossbeam::channel::SendError<Message>> {
        self.mailbox_sender.send(message)
    }
    
    pub fn receive_message(&self) -> Result<Message, crossbeam::channel::TryRecvError> {
        self.mailbox.try_recv()
    }
    
    pub fn receive_message_blocking(&self) -> Result<Message, crossbeam::channel::RecvError> {
        self.mailbox.recv()
    }
    
    pub fn has_messages(&self) -> bool {
        !self.mailbox.is_empty()
    }
    
    pub fn monitor_process(&mut self, target_pid: ProcId) -> String {
        let monitor_ref = format!("mon_{}_{}", self.id, target_pid);
        self.monitors.insert(monitor_ref.clone(), target_pid);
        monitor_ref
    }
    
    pub fn demonitor_process(&mut self, monitor_ref: &str) -> Option<ProcId> {
        self.monitors.remove(monitor_ref)
    }
    
    pub fn link_process(&mut self, target_pid: ProcId) {
        self.linked_processes.insert(target_pid);
    }
    
    pub fn unlink_process(&mut self, target_pid: ProcId) {
        self.linked_processes.remove(&target_pid);
    }
    
    pub fn add_monitor(&mut self, monitoring_pid: ProcId, monitor_ref: String) {
        self.monitored_by.insert(monitoring_pid, monitor_ref);
    }
    
    pub fn remove_monitor(&mut self, monitoring_pid: ProcId) -> Option<String> {
        self.monitored_by.remove(&monitoring_pid)
    }
    
    pub fn set_exit_reason(&mut self, reason: String) {
        self.exit_reason = Some(reason);
    }
    
    // Handle process exit by sending appropriate signals and cleanup
    pub fn handle_process_exit(&mut self, reason: String) {
        println!("Process {} exiting with reason: {}", self.id, reason);
        self.set_exit_reason(reason.clone());
        self.state = ProcState::Exited;
        
        // Send down messages to all monitors
        for (monitor_ref, monitored_pid) in self.monitors.iter() {
            if let Some(sender) = &self.message_sender {
                let down_msg = Message::Down(self.id, monitor_ref.clone(), reason.clone());
                println!("Sending down message to monitor {}: {:?}", monitored_pid, down_msg);
                let _ = sender.send_message(*monitored_pid, down_msg);
            }
        }
        
        // Send down messages to all processes monitoring this one
        for (monitoring_pid, monitor_ref) in self.monitored_by.iter() {
            if let Some(sender) = &self.message_sender {
                let down_msg = Message::Down(self.id, monitor_ref.clone(), reason.clone());
                println!("Sending down message to monitoring process {}: {:?}", monitoring_pid, down_msg);
                let _ = sender.send_message(*monitoring_pid, down_msg);
            }
        }
        
        // Send exit signals to all linked processes
        for linked_pid in self.linked_processes.iter() {
            if let Some(sender) = &self.message_sender {
                let exit_msg = Message::Exit(self.id);
                println!("Sending exit signal to linked process {}: {:?}", linked_pid, exit_msg);
                let _ = sender.send_message(*linked_pid, exit_msg);
            }
        }
        
        // Notify supervisor of child exit (if this process has a supervisor)
        if let Some(supervisor_pid) = self.supervisor_pid {
            if let Some(sender) = &self.message_sender {
                // Find the child name for this process
                // In a real implementation, this would be tracked properly
                let child_exit_msg = Message::Signal(format!("child_exit_{}_{}", self.id, reason));
                println!("Notifying supervisor {} of child {} exit: {}", supervisor_pid, self.id, reason);
                let _ = sender.send_message(supervisor_pid, child_exit_msg);
            }
        }
    }
    
    pub fn has_reductions_left(&self) -> bool {
        self.reduction_count < self.max_reductions
    }
    
    pub fn increment_reductions(&mut self) {
        self.reduction_count += 1;
    }
    
    pub fn reset_reductions(&mut self) {
        self.reduction_count = 0;
    }
    
    // Supervision helper methods
    fn can_restart_supervisor(&mut self) -> bool {
        if let Some(spec) = &self.supervisor_spec {
            let now = Instant::now();
            
            // If period has passed, reset intensity count
            if now.duration_since(self.restart_period_start) > spec.period {
                self.restart_intensity_count = 0;
                self.restart_period_start = now;
                return true;
            }
            
            // Check if we've exceeded the intensity limit
            self.restart_intensity_count < spec.intensity
        } else {
            false
        }
    }
    
    fn record_restart_supervisor(&mut self) {
        self.restart_intensity_count += 1;
    }
    
    fn should_restart_child(&self, child_spec: &ChildSpec, exit_reason: &str) -> bool {
        match child_spec.restart {
            RestartPolicy::Permanent => true,
            RestartPolicy::Temporary => false,
            RestartPolicy::Transient => exit_reason != "normal",
        }
    }
    
    fn start_child(&mut self, child_spec: &ChildSpec) -> Result<ProcId, String> {
        if let Some(spawner) = &self.process_spawner {
            let (child_pid, _) = spawner.spawn_process(child_spec.instructions.clone());
            
            let child_state = ChildState {
                pid: child_pid,
                spec: child_spec.clone(),
                restart_count: 0,
                last_restart: Instant::now(),
            };
            
            self.supervised_children.insert(child_spec.id.clone(), child_state);
            Ok(child_pid)
        } else {
            Err("No process spawner available".to_string())
        }
    }
    
    pub fn start_all_children(&mut self) -> Result<(), String> {
        if let Some(spec) = self.supervisor_spec.clone() {
            for child_spec in &spec.children {
                self.start_child(child_spec)?;
            }
        }
        Ok(())
    }
    
    // Pattern matching helper methods
    fn matches_pattern(&self, message: &Message, pattern: &MessagePattern) -> bool {
        match (message, pattern) {
            (_, MessagePattern::Any) => true,
            (Message::Value(val), MessagePattern::Value(pattern_val)) => val == pattern_val,
            (Message::Signal(sig), MessagePattern::Signal(pattern_sig)) => sig == pattern_sig,
            (Message::Exit(pid), MessagePattern::Exit(pattern_pid)) => {
                pattern_pid.is_none() || pattern_pid == &Some(*pid)
            }
            (Message::Down(pid, _ref, _reason), MessagePattern::Down(pattern_pid, _pattern_ref)) => {
                pattern_pid.is_none() || pattern_pid == &Some(*pid)
            }
            (Message::Link(pid), MessagePattern::Link(pattern_pid)) => {
                pattern_pid.is_none() || pattern_pid == &Some(*pid)
            }
            (Message::Value(val), MessagePattern::Type(type_name)) => {
                match (val, type_name.as_str()) {
                    (Value::Int(_), "int") => true,
                    (Value::Float(_), "float") => true,
                    (Value::Str(_), "string") => true,
                    (Value::Bool(_), "bool") => true,
                    (Value::List(_), "list") => true,
                    (Value::Object(_), "object") => true,
                    _ => false,
                }
            }
            _ => false,
        }
    }
    
    fn selective_receive(&mut self, patterns: &[MessagePattern]) -> Result<Option<Message>, String> {
        // Create a temporary vector to store messages that don't match
        let mut temp_messages = Vec::new();
        
        // Try to find a matching message
        let mut found_message = None;
        
        // Check all available messages
        while let Ok(msg) = self.receive_message() {
            let mut matched = false;
            
            for pattern in patterns {
                if self.matches_pattern(&msg, pattern) {
                    found_message = Some(msg.clone());
                    matched = true;
                    break;
                }
            }
            
            if matched {
                break;
            } else {
                temp_messages.push(msg);
            }
        }
        
        // Put back non-matching messages in original order
        for msg in temp_messages.into_iter().rev() {
            let _ = self.mailbox_sender.try_send(msg);
        }
        
        Ok(found_message)
    }
    

    pub fn step(&mut self) -> VMResult<bool> {
        if self.ip >= self.instructions.len() {
            self.handle_process_exit("normal".to_string());
            return Ok(false); // Process is done
        }
        
        if !self.has_reductions_left() {
            self.state = ProcState::Waiting;
            return Ok(false); // Out of reductions, yield
        }
        
        // Check for exit signals at the beginning of each instruction cycle
        // Process all available messages to handle exit signals immediately
        let mut exit_signal_received = false;
        
        while let Ok(msg) = self.receive_message() {
            match msg {
                Message::Exit(pid) => {
                    // Handle exit signal from linked process
                    println!("Process {} received exit signal from process {}", self.id, pid);
                    if self.linked_processes.contains(&pid) {
                        if self.trap_exit {
                            // Process traps exits - convert to regular message
                            println!("Process {} traps exits, converting exit signal to message", self.id);
                            let _ = self.mailbox_sender.send(Message::Exit(pid));
                        } else {
                            println!("Process {} is linked to {}, exiting due to exit signal", self.id, pid);
                            // In BEAM, linked processes normally exit when receiving exit signals
                            self.handle_process_exit(format!("exit_from_{}", pid));
                            exit_signal_received = true;
                            break;
                        }
                    } else {
                        println!("Process {} not linked to {}, discarding exit signal", self.id, pid);
                        // Not linked, just discard the message
                    }
                }
                Message::TrapExit(trap) => {
                    // Handle trap_exit setting
                    println!("Process {} setting trap_exit to {}", self.id, trap);
                    self.trap_exit = trap;
                }
                Message::Link(pid) => {
                    // Handle link request automatically - bidirectional linking
                    println!("Process {} received link request from process {}", self.id, pid);
                    let was_already_linked = self.linked_processes.contains(&pid);
                    println!("Process {} was already linked to {}: {}", self.id, pid, was_already_linked);
                    self.link_process(pid);
                    
                    // Send back link confirmation to make it bidirectional
                    // Only send if we weren't already linked to prevent infinite loop
                    if !was_already_linked {
                        if let Some(sender) = &self.message_sender {
                            let link_back_msg = Message::Link(self.id);
                            println!("Process {} sending link back message to process {}", self.id, pid);
                            let _ = sender.send_message(pid, link_back_msg);
                        }
                    }
                }
                Message::Unlink(pid) => {
                    // Handle unlink request automatically
                    println!("Process {} received unlink request from process {}", self.id, pid);
                    self.unlink_process(pid);
                }
                Message::Monitor(pid, monitor_ref) => {
                    // Handle monitor request automatically
                    println!("Process {} received monitor request from process {} with ref {}", self.id, pid, monitor_ref);
                    self.add_monitor(pid, monitor_ref);
                }
                Message::Down(pid, monitor_ref, reason) => {
                    // Handle down message automatically for immediate delivery
                    println!("Process {} received down message: pid={}, ref={}, reason={}", self.id, pid, monitor_ref, reason);
                    // Put it back in the queue for the Receive instruction to pick up
                    let _ = self.mailbox_sender.send(Message::Down(pid, monitor_ref, reason));
                }
                _ => {
                    // Other messages go back to queue for Receive to handle
                    let _ = self.mailbox_sender.send(msg);
                }
            }
        }
        
        if exit_signal_received {
            return Ok(false);
        }
        
        let instruction = &self.instructions[self.ip].clone();
        self.increment_reductions();
        self.instruction_count += 1;
        
        if self.trace_enabled {
            let indent = "  ".repeat(self.call_stack.len());
            println!("{} {}{} @ {}", 
                     "[trace]".bright_blue(),
                     indent, 
                     format!("{:?}", instruction).white(),
                     format!("0x{:04X}", self.ip).cyan());
        }
        
        self.execute_instruction_safe(instruction)?;
        
        // Check if process state changed during instruction execution
        match self.state {
            ProcState::Exited => Ok(false),  // Process is done
            ProcState::Waiting => Ok(false), // Process yielded
            _ => Ok(true), // Continue execution
        }
    }
    
    pub fn run_until_yield(&mut self) -> VMResult<ProcState> {
        self.state = ProcState::Running;
        self.reset_reductions();
        
        loop {
            match self.step()? {
                true => continue,  // Keep running
                false => break,    // Yielded or exited
            }
        }
        
        Ok(self.state)
    }
    
    fn pop_stack(&mut self, operation: &str) -> VMResult<Value> {
        self.stack.pop().ok_or_else(|| VMError::StackUnderflow(operation.to_string()))
    }

    fn peek_stack(&self, operation: &str) -> VMResult<&Value> {
        self.stack.last().ok_or_else(|| VMError::StackUnderflow(operation.to_string()))
    }

    fn check_stack_size(&self, needed: usize, _operation: &str) -> VMResult<()> {
        if self.stack.len() < needed {
            return Err(VMError::StackUnderflow(_operation.to_string()));
        }
        Ok(())
    }
    
    fn execute_instruction_safe(&mut self, instruction: &OpCode) -> VMResult<()> {
        // For now, implement a simplified version that handles basic operations
        // This can be expanded later as needed
        match instruction {
            OpCode::PushInt(n) => self.stack.push(Value::Int(*n)),
            OpCode::PushFloat(f) => self.stack.push(Value::Float(*f)),
            OpCode::PushStr(s) => self.stack.push(Value::Str(s.clone())),
            OpCode::PushBool(b) => self.stack.push(Value::Bool(*b)),
            OpCode::Print => {
                let val = self.pop_stack("PRINT")?;
                println!("{}", val);
            }
            OpCode::Add => {
                let b = self.pop_stack("ADD")?;
                let a = self.pop_stack("ADD")?;
                match (&a, &b) {
                    (Value::Int(x), Value::Int(y)) => self.stack.push(Value::Int(x + y)),
                    (Value::Int(x), Value::Float(y)) => self.stack.push(Value::Float(*x as f64 + y)),
                    (Value::Float(x), Value::Int(y)) => self.stack.push(Value::Float(x + *y as f64)),
                    (Value::Float(x), Value::Float(y)) => self.stack.push(Value::Float(x + y)),
                    _ => return Err(VMError::TypeMismatch { 
                        expected: "two numbers (int or float)".to_string(), 
                        got: format!("{:?}, {:?}", a, b), 
                        operation: "ADD".to_string() 
                    }),
                }
            }
            OpCode::Mul => {
                let b = self.pop_stack("MUL")?;
                let a = self.pop_stack("MUL")?;
                match (&a, &b) {
                    (Value::Int(x), Value::Int(y)) => self.stack.push(Value::Int(x * y)),
                    (Value::Int(x), Value::Float(y)) => self.stack.push(Value::Float(*x as f64 * y)),
                    (Value::Float(x), Value::Int(y)) => self.stack.push(Value::Float(x * *y as f64)),
                    (Value::Float(x), Value::Float(y)) => self.stack.push(Value::Float(x * y)),
                    _ => return Err(VMError::TypeMismatch { 
                        expected: "two numbers (int or float)".to_string(), 
                        got: format!("{:?}, {:?}", a, b), 
                        operation: "MUL".to_string() 
                    }),
                }
            }
            OpCode::Div => {
                let b = self.pop_stack("DIV")?;
                let a = self.pop_stack("DIV")?;
                match (&a, &b) {
                    (Value::Int(x), Value::Int(y)) => {
                        if *y == 0 {
                            return Err(VMError::DivisionByZero);
                        }
                        self.stack.push(Value::Int(x / y));
                    },
                    (Value::Int(x), Value::Float(y)) => {
                        if *y == 0.0 {
                            return Err(VMError::DivisionByZero);
                        }
                        self.stack.push(Value::Float(*x as f64 / y));
                    },
                    (Value::Float(x), Value::Int(y)) => {
                        if *y == 0 {
                            return Err(VMError::DivisionByZero);
                        }
                        self.stack.push(Value::Float(x / *y as f64));
                    },
                    (Value::Float(x), Value::Float(y)) => {
                        if *y == 0.0 {
                            return Err(VMError::DivisionByZero);
                        }
                        self.stack.push(Value::Float(x / y));
                    },
                    _ => return Err(VMError::TypeMismatch { 
                        expected: "two numbers (int or float)".to_string(), 
                        got: format!("{:?}, {:?}", a, b), 
                        operation: "DIV".to_string() 
                    }),
                }
            }
            OpCode::Halt => {
                self.handle_process_exit("normal".to_string());
                // Don't advance IP for Halt - process is done
                return Ok(());
            }
            OpCode::Spawn => {
                // For now, spawn a simple process with basic instructions
                // In a real implementation, we'd parse the function from the stack
                let function_value = self.pop_stack("SPAWN")?;
                
                // Try to load the function as a ttvm file
                let new_process_instructions = match function_value {
                    Value::Str(ref s) => {
                        // Try to load from examples directory first
                        let mut file_path = format!("examples/{}.ttvm", s);
                        if !std::path::Path::new(&file_path).exists() {
                            // Try current directory
                            file_path = format!("{}.ttvm", s);
                        }
                        
                        if std::path::Path::new(&file_path).exists() {
                            // Load and parse the ttvm file
                            match parse_program(&file_path) {
                                Ok(instructions) => instructions,
                                Err(e) => {
                                    eprintln!("Failed to parse {}: {}", file_path, e);
                                    vec![
                                        OpCode::PushStr(format!("Failed to load {}", s)),
                                        OpCode::Print,
                                        OpCode::Halt,
                                    ]
                                }
                            }
                        } else {
                            // Fallback to hardcoded processes for backward compatibility
                            match s.as_str() {
                                "hello_world" => {
                                    vec![
                                        OpCode::PushStr("Hello from spawned process!".to_string()),
                                        OpCode::Print,
                                        OpCode::Halt,
                                    ]
                                }
                                "counter" => {
                                    vec![
                                        OpCode::PushInt(1),
                                        OpCode::Print,
                                        OpCode::PushInt(2),
                                        OpCode::Print,
                                        OpCode::PushInt(3),
                                        OpCode::Print,
                                        OpCode::Halt,
                                    ]
                                }
                                _ => {
                                    // Default: spawn a simple process
                                    vec![
                                        OpCode::PushStr(format!("Spawned process: {}", s)),
                                        OpCode::Print,
                                        OpCode::Halt,
                                    ]
                                }
                            }
                        }
                    }
                    _ => {
                        // Non-string values default to simple process
                        vec![
                            OpCode::PushStr("Spawned process".to_string()),
                            OpCode::Print,
                            OpCode::Halt,
                        ]
                    }
                };
                
                // Spawn the new process
                if let Some(spawner) = &self.process_spawner {
                    let (new_proc_id, _sender) = spawner.spawn_process(new_process_instructions);
                    self.stack.push(Value::Int(new_proc_id as i64));
                } else {
                    eprintln!("No process spawner available for process {}", self.id);
                    self.stack.push(Value::Int(0)); // Push dummy process ID
                }
            }
            OpCode::Receive => {
                // Try to receive a message from mailbox
                match self.receive_message() {
                    Ok(msg) => {
                        // Message received successfully
                        self.waiting_for_message = false;
                        match msg {
                            Message::Value(val) => self.stack.push(val),
                            Message::Signal(sig) => self.stack.push(Value::Str(sig)),
                            Message::Exit(pid) => {
                                // Handle exit signal from linked process
                                if self.linked_processes.contains(&pid) {
                                    // In BEAM, linked processes normally exit when receiving exit signals
                                    // For now, we'll implement basic exit propagation
                                    self.handle_process_exit(format!("exit_from_{}", pid));
                                    return Ok(());
                                } else {
                                    // Not linked, just treat as regular message
                                    self.stack.push(Value::Int(pid as i64));
                                }
                            }
                            Message::Monitor(pid, monitor_ref) => {
                                // Handle monitor request
                                self.add_monitor(pid, monitor_ref.clone());
                                self.stack.push(Value::Str(format!("monitor:{}", monitor_ref)));
                            }
                            Message::Down(pid, monitor_ref, reason) => {
                                // Handle down message
                                self.stack.push(Value::Str(format!("down:{}:{}:{}", pid, monitor_ref, reason)));
                            }
                            Message::Link(pid) => {
                                // Handle link request - bidirectional linking
                                println!("Process {} received link request from process {}", self.id, pid);
                                let was_already_linked = self.linked_processes.contains(&pid);
                                println!("Process {} was already linked to {}: {}", self.id, pid, was_already_linked);
                                self.link_process(pid);
                                
                                // Send back link confirmation to make it bidirectional
                                // Only send if we weren't already linked to prevent infinite loop
                                if !was_already_linked {
                                    if let Some(sender) = &self.message_sender {
                                        let link_back_msg = Message::Link(self.id);
                                        println!("Process {} sending link back message to process {}", self.id, pid);
                                        let _ = sender.send_message(pid, link_back_msg);
                                    }
                                }
                                
                                self.stack.push(Value::Str(format!("linked:{}", pid)));
                            }
                            Message::Unlink(pid) => {
                                // Handle unlink request
                                self.unlink_process(pid);
                                self.stack.push(Value::Str(format!("unlinked:{}", pid)));
                            }
                            Message::TrapExit(trap) => {
                                // Handle trap_exit setting
                                self.trap_exit = trap;
                                self.stack.push(Value::Bool(trap));
                            }
                        }
                    }
                    Err(_) => {
                        // No message available, mark as waiting and yield
                        self.waiting_for_message = true;
                        self.state = ProcState::Waiting;
                        // Don't advance IP - we want to retry this instruction when rescheduled
                        return Ok(());
                    }
                }
            }
            OpCode::ReceiveMatch(patterns) => {
                // Try selective receive with pattern matching
                match self.selective_receive(patterns) {
                    Ok(Some(msg)) => {
                        // Message received successfully
                        self.waiting_for_message = false;
                        match msg {
                            Message::Value(val) => self.stack.push(val),
                            Message::Signal(sig) => self.stack.push(Value::Str(sig)),
                            Message::Exit(pid) => {
                                if self.trap_exit {
                                    // Process traps exits - put exit message on stack
                                    self.stack.push(Value::Str(format!("exit:{}", pid)));
                                } else if self.linked_processes.contains(&pid) {
                                    // In BEAM, linked processes normally exit when receiving exit signals
                                    self.handle_process_exit(format!("exit_from_{}", pid));
                                    return Ok(());
                                } else {
                                    // Not linked, treat as regular message
                                    self.stack.push(Value::Int(pid as i64));
                                }
                            }
                            Message::Monitor(pid, monitor_ref) => {
                                // Handle monitor request
                                self.add_monitor(pid, monitor_ref.clone());
                                self.stack.push(Value::Str(format!("monitor:{}", monitor_ref)));
                            }
                            Message::Down(pid, monitor_ref, reason) => {
                                // Handle down message
                                self.stack.push(Value::Str(format!("down:{}:{}:{}", pid, monitor_ref, reason)));
                            }
                            Message::Link(pid) => {
                                // Handle link request - bidirectional linking
                                println!("Process {} received link request from process {}", self.id, pid);
                                let was_already_linked = self.linked_processes.contains(&pid);
                                self.link_process(pid);
                                
                                // Send back link confirmation to make it bidirectional
                                if !was_already_linked {
                                    if let Some(sender) = &self.message_sender {
                                        let link_back_msg = Message::Link(self.id);
                                        let _ = sender.send_message(pid, link_back_msg);
                                    }
                                }
                                
                                self.stack.push(Value::Str(format!("linked:{}", pid)));
                            }
                            Message::Unlink(pid) => {
                                // Handle unlink request
                                self.unlink_process(pid);
                                self.stack.push(Value::Str(format!("unlinked:{}", pid)));
                            }
                            Message::TrapExit(trap) => {
                                // Handle trap_exit setting
                                self.trap_exit = trap;
                                self.stack.push(Value::Bool(trap));
                            }
                        }
                    }
                    Ok(None) => {
                        // No matching message available, mark as waiting and yield
                        self.waiting_for_message = true;
                        self.state = ProcState::Waiting;
                        // Don't advance IP - we want to retry this instruction when rescheduled
                        return Ok(());
                    }
                    Err(e) => {
                        return Err(VMError::RuntimeError(format!("Selective receive error: {}", e)));
                    }
                }
            }
            OpCode::Yield => {
                // Manually yield to scheduler
                self.ip += 1; // Advance IP before yielding
                self.state = ProcState::Waiting;
                return Ok(());
            }
            OpCode::Send(target_proc_id) => {
                // Get the message value from the stack
                let message_value = self.pop_stack("SEND")?;
                
                // Convert Value to Message
                let message = Message::Value(message_value);
                
                // Send message using the message sender
                if let Some(sender) = &self.message_sender {
                    match sender.send_message(*target_proc_id, message) {
                        Ok(_) => {
                            // Message sent successfully
                            println!("Process {} sent message to process {}", self.id, target_proc_id);
                        }
                        Err(e) => {
                            eprintln!("Failed to send message to process {}: {}", target_proc_id, e);
                            // In a real implementation, we might want to handle this error differently
                        }
                    }
                } else {
                    eprintln!("No message sender available for process {}", self.id);
                }
            }
            OpCode::Monitor(target_proc_id) => {
                // Monitor a process - add it to our monitors list
                let monitor_ref = self.monitor_process(*target_proc_id);
                
                // Send monitor request to the scheduler
                if let Some(sender) = &self.message_sender {
                    let monitor_msg = Message::Monitor(self.id, monitor_ref.clone());
                    println!("Process {} sending monitor request to process {}", self.id, target_proc_id);
                    match sender.send_message(*target_proc_id, monitor_msg) {
                        Ok(_) => {
                            // Push monitor reference to stack for use by the process
                            println!("Process {} successfully sent monitor request to process {}", self.id, target_proc_id);
                            self.stack.push(Value::Str(monitor_ref));
                        }
                        Err(e) => {
                            eprintln!("Failed to send monitor request to process {}: {}", target_proc_id, e);
                            // Remove from monitors if sending failed
                            self.demonitor_process(&monitor_ref);
                            self.stack.push(Value::Str("monitor_failed".to_string()));
                        }
                    }
                } else {
                    eprintln!("No message sender available for process {}", self.id);
                    self.stack.push(Value::Str("monitor_failed".to_string()));
                }
            }
            OpCode::Demonitor(monitor_ref) => {
                // Stop monitoring a process
                if let Some(target_proc_id) = self.demonitor_process(monitor_ref) {
                    // Send demonitor request to the target process
                    if let Some(sender) = &self.message_sender {
                        let demonitor_msg = Message::Monitor(self.id, format!("stop_{}", monitor_ref));
                        match sender.send_message(target_proc_id, demonitor_msg) {
                            Ok(_) => {
                                self.stack.push(Value::Str("demonitor_success".to_string()));
                            }
                            Err(e) => {
                                eprintln!("Failed to send demonitor request to process {}: {}", target_proc_id, e);
                                self.stack.push(Value::Str("demonitor_failed".to_string()));
                            }
                        }
                    } else {
                        eprintln!("No message sender available for process {}", self.id);
                        self.stack.push(Value::Str("demonitor_failed".to_string()));
                    }
                } else {
                    // Monitor reference not found
                    self.stack.push(Value::Str("monitor_not_found".to_string()));
                }
            }
            OpCode::Link(target_proc_id) => {
                // Link to a process - bidirectional link
                println!("Process {} linking to process {}", self.id, target_proc_id);
                self.link_process(*target_proc_id);
                
                // Send link request to the target process
                if let Some(sender) = &self.message_sender {
                    let link_msg = Message::Link(self.id);
                    println!("Process {} sending link message to process {}", self.id, target_proc_id);
                    match sender.send_message(*target_proc_id, link_msg) {
                        Ok(_) => {
                            println!("Process {} successfully sent link message to process {}", self.id, target_proc_id);
                            self.stack.push(Value::Str(format!("linked_{}", target_proc_id)));
                        }
                        Err(e) => {
                            eprintln!("Failed to send link request to process {}: {}", target_proc_id, e);
                            // Remove link if sending failed
                            self.unlink_process(*target_proc_id);
                            self.stack.push(Value::Str("link_failed".to_string()));
                        }
                    }
                } else {
                    eprintln!("No message sender available for process {}", self.id);
                    self.stack.push(Value::Str("link_failed".to_string()));
                }
            }
            OpCode::Unlink(target_proc_id) => {
                // Unlink from a process
                self.unlink_process(*target_proc_id);
                
                // Send unlink request to the target process
                if let Some(sender) = &self.message_sender {
                    let unlink_msg = Message::Unlink(self.id);
                    match sender.send_message(*target_proc_id, unlink_msg) {
                        Ok(_) => {
                            self.stack.push(Value::Str(format!("unlinked_{}", target_proc_id)));
                        }
                        Err(e) => {
                            eprintln!("Failed to send unlink request to process {}: {}", target_proc_id, e);
                            self.stack.push(Value::Str("unlink_failed".to_string()));
                        }
                    }
                } else {
                    eprintln!("No message sender available for process {}", self.id);
                    self.stack.push(Value::Str("unlink_failed".to_string()));
                }
            }
            OpCode::TrapExit => {
                // Set trap_exit flag from stack
                let trap_value = self.pop_stack("TRAP_EXIT")?;
                match trap_value {
                    Value::Bool(trap) => {
                        self.trap_exit = trap;
                        println!("Process {} set trap_exit to {}", self.id, trap);
                    }
                    _ => return Err(VMError::TypeError("TRAP_EXIT requires boolean value".to_string())),
                }
            }
            OpCode::Register(name) => {
                // Register current process with a name
                if let Some(registry) = &self.name_registry {
                    match registry.register_name(name.clone(), self.id) {
                        Ok(_) => self.stack.push(Value::Str(format!("registered_{}", name))),
                        Err(e) => self.stack.push(Value::Str(format!("register_failed_{}", e))),
                    }
                } else {
                    self.stack.push(Value::Str("register_failed_no_registry".to_string()));
                }
            }
            OpCode::Unregister(name) => {
                // Unregister a name
                if let Some(registry) = &self.name_registry {
                    match registry.unregister_name(name) {
                        Ok(_) => self.stack.push(Value::Str(format!("unregistered_{}", name))),
                        Err(e) => self.stack.push(Value::Str(format!("unregister_failed_{}", e))),
                    }
                } else {
                    self.stack.push(Value::Str("unregister_failed_no_registry".to_string()));
                }
            }
            OpCode::Whereis(name) => {
                // Find PID by name (returns 0 if not found)
                if let Some(registry) = &self.name_registry {
                    match registry.whereis(name) {
                        Some(proc_id) => self.stack.push(Value::Int(proc_id as i64)),
                        None => self.stack.push(Value::Int(0)),
                    }
                } else {
                    self.stack.push(Value::Int(0));
                }
            }
            OpCode::SendNamed(name) => {
                // Send message to named process
                let message_value = self.pop_stack("SEND_NAMED")?;
                
                if let Some(registry) = &self.name_registry {
                    let message = Message::Value(message_value);
                    match registry.send_to_named(name, message) {
                        Ok(_) => self.stack.push(Value::Str(format!("sent_to_{}", name))),
                        Err(e) => self.stack.push(Value::Str(format!("send_failed_{}", e))),
                    }
                } else {
                    self.stack.push(Value::Str("send_failed_no_registry".to_string()));
                }
            }
            OpCode::StartSupervisor => {
                // This opcode is used to start supervisor functionality
                // The actual supervisor is created with new_supervisor()
                self.stack.push(Value::Str("supervisor_started".to_string()));
            }
            OpCode::SuperviseChild(child_name) => {
                // Supervise a child process - for now just mark it as supervised
                // The actual child process would be spawned separately
                self.stack.push(Value::Str(format!("supervising_{}", child_name)));
            }
            OpCode::RestartChild(child_name) => {
                // Restart a specific child process with safety measures
                if self.supervisor_spec.is_some() {
                    if self.supervised_children.contains_key(child_name) {
                        // Check if we can restart this child (prevents infinite loops)
                        if self.can_restart_supervisor() {
                            self.record_restart_supervisor();
                            
                            // In a real implementation, this would:
                            // 1. Terminate the old child process
                            // 2. Spawn a new child process with the same instructions
                            // 3. Update the supervised_children mapping
                            self.stack.push(Value::Str(format!("restarting_{}", child_name)));
                            
                            // For now, just simulate the restart
                            eprintln!("Supervisor {} safely restarting child {}", self.id, child_name);
                        } else {
                            self.stack.push(Value::Str(format!("restart_limit_exceeded_{}", child_name)));
                            eprintln!("Supervisor {} cannot restart child {} - too many restarts", self.id, child_name);
                        }
                    } else {
                        self.stack.push(Value::Str(format!("child_not_found_{}", child_name)));
                    }
                } else {
                    self.stack.push(Value::Str("not_supervisor".to_string()));
                }
            }
            _ => {
                // For now, just advance IP for unsupported instructions
                // TODO: Implement full instruction set
                self.ip += 1;
                return Ok(());
            }
        }
        
        self.ip += 1;
        Ok(())
    }
}









impl VM {
    fn new(instructions: Vec<OpCode>) -> Self {
        Self::new_with_gc(instructions, "mark-sweep", false, false)
    }

    #[allow(dead_code)]
    fn new_with_debug(instructions: Vec<OpCode>, debug_mode: bool) -> Self {
        Self::new_with_gc(instructions, "mark-sweep", debug_mode, false)
    }

    fn new_with_gc(instructions: Vec<OpCode>, gc_type: &str, debug_mode: bool, gc_stats_enabled: bool) -> Self {
        Self::new_with_config(instructions, gc_type, debug_mode, gc_stats_enabled, false, false)
    }

    fn new_with_config(instructions: Vec<OpCode>, gc_type: &str, debug_mode: bool, gc_stats_enabled: bool, trace_enabled: bool, profile_enabled: bool) -> Self {
        let gc_engine: Box<dyn GcEngine> = match gc_type {
            "no-gc" => Box::new(NoGc::new()),
            "mark-sweep" => Box::new(MarkSweepGc::new(debug_mode)),
            _ => Box::new(MarkSweepGc::new(debug_mode)), // Default to mark-sweep
        };

        VM {
            stack: Vec::with_capacity(1024), // Pre-allocate stack capacity
            instructions,
            ip: 0,
            call_stack: Vec::with_capacity(64), // Pre-allocate call stack
            variables: vec![HashMap::new()], // global frame
            try_stack: Vec::new(),
            exports: HashMap::new(),
            loaded_modules: HashMap::new(),
            loading_stack: Vec::new(),
            lambda_captures: HashMap::new(),
            max_stack_size: 0,
            instruction_count: 0,
            debug_mode,
            breakpoints: Vec::new(),
            gc_engine,
            _gc_stats_enabled: gc_stats_enabled,
            profiler: if profile_enabled { Some(Profiler::new()) } else { None },
            trace_enabled,
        }
    }

    #[allow(dead_code)]
    fn add_breakpoint(&mut self, address: usize) {
        if !self.breakpoints.contains(&address) {
            self.breakpoints.push(address);
            self.breakpoints.sort();
        }
    }

    #[allow(dead_code)]
    fn remove_breakpoint(&mut self, address: usize) {
        self.breakpoints.retain(|&x| x != address);
    }

    fn get_stats(&self) -> (usize, usize, usize) {
        (self.instruction_count, self.max_stack_size, self.stack.len())
    }

    fn get_gc_stats(&self) -> GcStats {
        self.gc_engine.stats()
    }

    #[allow(dead_code)]
    fn trigger_gc(&mut self) {
        // Collect roots from stack and variables
        let mut roots: Vec<&Value> = Vec::new();
        
        // Add stack values as roots
        for value in &self.stack {
            roots.push(value);
        }
        
        // Add variables as roots
        for frame in &self.variables {
            for (_name, value) in frame {
                roots.push(value);
            }
        }
        
        // Mark from roots
        self.gc_engine.mark_from_roots(&roots);
        
        // Sweep unreachable objects
        let collected = self.gc_engine.sweep();
        
        if self.debug_mode {
            println!("GC triggered: collected {} objects", collected);
        }
    }

    // Safe stack operations
    fn pop_stack(&mut self, operation: &str) -> VMResult<Value> {
        self.stack.pop().ok_or_else(|| VMError::StackUnderflow(operation.to_string()))
    }

    fn peek_stack(&self, operation: &str) -> VMResult<&Value> {
        self.stack.last().ok_or_else(|| VMError::StackUnderflow(operation.to_string()))
    }

    fn check_stack_size(&self, needed: usize, _operation: &str) -> VMResult<()> {
        if self.stack.len() < needed {
            Err(VMError::InsufficientStackItems { 
                needed, 
                available: self.stack.len() 
            })
        } else {
            Ok(())
        }
    }

    fn get_variable(&self, name: &str) -> VMResult<Value> {
        self.variables
            .last()
            .ok_or(VMError::NoVariableScope)?
            .get(name)
            .cloned()
            .ok_or_else(|| VMError::UndefinedVariable(name.to_string()))
    }

    fn set_variable(&mut self, name: String, value: Value) -> VMResult<()> {
        self.variables
            .last_mut()
            .ok_or(VMError::NoVariableScope)?
            .insert(name, value);
        Ok(())
    }

    fn pop_call_stack(&mut self) -> VMResult<usize> {
        self.call_stack.pop().ok_or(VMError::CallStackUnderflow)
    }

    fn pop_variable_frame(&mut self) -> VMResult<()> {
        if self.variables.len() <= 1 {
            Err(VMError::NoVariableScope)
        } else {
            self.variables.pop();
            Ok(())
        }
    }

    // Exception handling methods
    fn push_exception_handler(&mut self, catch_addr: usize) {
        let handler = ExceptionHandler {
            catch_addr,
            stack_size: self.stack.len(),
            call_stack_size: self.call_stack.len(),
            variable_frames: self.variables.len(),
        };
        self.try_stack.push(handler);
    }

    fn pop_exception_handler(&mut self) -> Option<ExceptionHandler> {
        self.try_stack.pop()
    }

    fn unwind_to_exception_handler(&mut self, handler: &ExceptionHandler) {
        // Unwind stack to the state when try block started
        self.stack.truncate(handler.stack_size);
        
        // Unwind call stack
        self.call_stack.truncate(handler.call_stack_size);
        
        // Unwind variable frames
        self.variables.truncate(handler.variable_frames);
    }

    fn throw_exception(&mut self, exception: Value) -> VMResult<()> {
        if let Some(handler) = self.pop_exception_handler() {
            // Unwind to the try block state
            self.unwind_to_exception_handler(&handler);
            
            // Push the exception onto the stack for the catch block
            self.stack.push(exception);
            
            // Jump to the catch block
            self.ip = handler.catch_addr;
            Ok(())
        } else {
            // No exception handler found, convert to VM error
            match exception {
                Value::Exception { message, .. } => {
                    Err(VMError::ParseError { line: self.ip, instruction: format!("Unhandled exception: {}", message) })
                }
                _ => {
                    Err(VMError::ParseError { line: self.ip, instruction: format!("Unhandled exception: {:?}", exception) })
                }
            }
        }
    }

    fn run(&mut self) -> VMResult<()> {
        while self.ip < self.instructions.len() {
            // Performance tracking
            self.instruction_count += 1;
            if self.stack.len() > self.max_stack_size {
                self.max_stack_size = self.stack.len();
            }

            // Profiling support
            if let Some(ref mut profiler) = self.profiler {
                profiler.record_instruction();
                profiler.update_stack_depth(self.stack.len());
            }

            // Tracing support
            if self.trace_enabled {
                let instruction = &self.instructions[self.ip];
                let indent = if let Some(ref profiler) = self.profiler {
                    "  ".repeat(profiler.call_depth)
                } else {
                    String::new()
                };
                println!("{} {}{} @ {}", 
                         "[trace]".bright_blue(),
                         indent, 
                         format!("{:?}", instruction).white(),
                         format!("0x{:04X}", self.ip).cyan());
            }

            // Debugging support
            if self.debug_mode {
                println!("IP: {}, Instruction: {:?}, Stack size: {}", 
                    self.ip, self.instructions[self.ip], self.stack.len());
            }

            // Breakpoint support
            if self.breakpoints.contains(&self.ip) {
                println!("Breakpoint hit at instruction {}: {:?}", 
                    self.ip, self.instructions[self.ip]);
                println!("Stack: {:?}", self.stack);
                println!("Variables: {:?}", self.variables.last());
                // In a real debugger, we'd wait for user input here
            }

            let instruction = &self.instructions[self.ip].clone();
            
            // Store original IP to detect jumps
            let original_ip = self.ip;
            
            // Check for HALT instruction first
            if matches!(instruction, OpCode::Halt) {
                break;
            }
            
            // Execute instruction and catch VM errors in try blocks
            match self.execute_instruction_safe(instruction) {
                Ok(()) => {
                    // Only increment IP if instruction didn't change it
                    if self.ip == original_ip {
                        self.ip += 1;
                    }
                }
                Err(vm_error) => {
                    // If we're in a try block, convert VM error to exception
                    if !self.try_stack.is_empty() {
                        let exception = Value::Exception {
                            message: vm_error.to_string(),
                            stack_trace: vec![format!("at instruction {}", self.ip)]
                        };
                        self.throw_exception(exception)?;
                        continue;
                    } else {
                        return Err(vm_error);
                    }
                }
            }
        }
        Ok(())
    }

    fn execute_instruction_safe(&mut self, instruction: &OpCode) -> VMResult<()> {
        match instruction {
                OpCode::PushInt(n) => self.stack.push(Value::Int(*n)),
                OpCode::PushFloat(f) => self.stack.push(Value::Float(*f)),
                OpCode::PushStr(s) => self.stack.push(Value::Str(s.clone())),
                OpCode::PushBool(b) => self.stack.push(Value::Bool(*b)),
                OpCode::Add => {
                    let b = self.pop_stack("ADD")?;
                    let a = self.pop_stack("ADD")?;
                    match (&a, &b) {
                        (Value::Int(x), Value::Int(y)) => self.stack.push(Value::Int(x + y)),
                        // Type coercion: int + float = float
                        (Value::Int(x), Value::Float(y)) => self.stack.push(Value::Float(*x as f64 + y)),
                        (Value::Float(x), Value::Int(y)) => self.stack.push(Value::Float(x + *y as f64)),
                        (Value::Float(x), Value::Float(y)) => self.stack.push(Value::Float(x + y)),
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "two numbers (int or float)".to_string(), 
                            got: format!("{:?}, {:?}", a, b), 
                            operation: "ADD".to_string() 
                        }),
                    }
                }
                OpCode::AddF => {
                    let b = self.pop_stack("ADD_F")?;
                    let a = self.pop_stack("ADD_F")?;
                    match (&a, &b) {
                        (Value::Float(x), Value::Float(y)) => self.stack.push(Value::Float(x + y)),
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "two floats".to_string(), 
                            got: format!("{:?}, {:?}", a, b), 
                            operation: "ADD_F".to_string() 
                        }),
                    }
                }
                OpCode::SubF => {
                    let b = self.pop_stack("SUB_F")?;
                    let a = self.pop_stack("SUB_F")?;
                    match (&a, &b) {
                        (Value::Float(x), Value::Float(y)) => self.stack.push(Value::Float(x - y)),
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "two floats".to_string(), 
                            got: format!("{:?}, {:?}", a, b), 
                            operation: "SUB_F".to_string() 
                        }),
                    }
                }
                OpCode::MulF => {
                    let b = self.pop_stack("MUL_F")?;
                    let a = self.pop_stack("MUL_F")?;
                    match (&a, &b) {
                        (Value::Float(x), Value::Float(y)) => self.stack.push(Value::Float(x * y)),
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "two floats".to_string(), 
                            got: format!("{:?}, {:?}", a, b), 
                            operation: "MUL_F".to_string() 
                        }),
                    }
                }
                OpCode::DivF => {
                    let b = self.pop_stack("DIV_F")?;
                    let a = self.pop_stack("DIV_F")?;
                    match (&a, &b) {
                        (Value::Float(x), Value::Float(y)) => {
                            if *y == 0.0 {
                                return Err(VMError::TypeMismatch { 
                                    expected: "non-zero divisor".to_string(), 
                                    got: "zero".to_string(), 
                                    operation: "DIV_F".to_string() 
                                });
                            }
                            self.stack.push(Value::Float(x / y));
                        }
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "two floats".to_string(), 
                            got: format!("{:?}, {:?}", a, b), 
                            operation: "DIV_F".to_string() 
                        }),
                    }
                }
                OpCode::Concat => {
                    let b = self.pop_stack("CONCAT")?;
                    let a = self.pop_stack("CONCAT")?;
                    match (&a, &b) {
                        (Value::Str(x), Value::Str(y)) => self.stack.push(Value::Str(x.clone() + y)),
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "two strings".to_string(), 
                            got: format!("{:?}, {:?}", a, b), 
                            operation: "CONCAT".to_string() 
                        }),
                    }
                }
                OpCode::Print => {
                    let val = self.pop_stack("PRINT")?;
                    println!("{}", val);
                }
                OpCode::Jmp(target) => {
                    self.ip = *target;
                }
                OpCode::Jz(target) => {
                    let val = self.pop_stack("JZ")?;
                    let is_zero = match val {
                        Value::Int(0) => true,
                        Value::Bool(false) => true,
                        Value::Null => true,
                        _ => false,
                    };
                    if is_zero {
                        self.ip = *target;
                    }
                }
                OpCode::Call{ addr, params } => {
                    self.check_stack_size(params.len(), "CALL")?;
                    
                    // Create function name for profiling/tracing
                    let function_name = format!("fn@0x{:04X}", addr);
                    
                    // Function call tracing
                    if self.trace_enabled {
                        let indent = if let Some(ref profiler) = self.profiler {
                            "  ".repeat(profiler.call_depth)
                        } else {
                            String::new()
                        };
                        println!("{} {}CALL {} with {} params", 
                                 "[trace]".bright_blue(),
                                 indent, 
                                 function_name.yellow(),
                                 format!("{}", params.len()).green());
                    }
                    
                    // Function profiling
                    if let Some(ref mut profiler) = self.profiler {
                        profiler.start_function(function_name);
                    }
                    
                    self.call_stack.push(self.ip + 1);
                    let mut frame = HashMap::new();
                    for name in params.iter().rev() {
                        let value = self.pop_stack("CALL")?;
                        frame.insert(name.clone(), value);
                    }
                    self.variables.push(frame);
                    self.ip = *addr;
                }
                OpCode::Ret => {
                    // Function return tracing and profiling
                    if let Some(ref mut profiler) = self.profiler {
                        if let Some(function_name) = profiler.end_function() {
                            if self.trace_enabled {
                                let indent = "  ".repeat(profiler.call_depth);
                                let return_value = if !self.stack.is_empty() {
                                    format!(" → {:?}", self.stack.last().unwrap())
                                } else {
                                    String::new()
                                };
                                println!("{} {}RETURN from {}{}", 
                                         "[trace]".bright_blue(),
                                         indent, 
                                         function_name.yellow(),
                                         return_value.green());
                            }
                        }
                    }
                    
                    self.pop_variable_frame()?;
                    self.ip = self.pop_call_stack()?;
                }
                OpCode::Sub => {
                    let b = self.pop_stack("SUB")?;
                    let a = self.pop_stack("SUB")?;
                    match (&a, &b) {
                        (Value::Int(x), Value::Int(y)) => self.stack.push(Value::Int(x - y)),
                        // Type coercion: mixed int/float = float
                        (Value::Int(x), Value::Float(y)) => self.stack.push(Value::Float(*x as f64 - y)),
                        (Value::Float(x), Value::Int(y)) => self.stack.push(Value::Float(x - *y as f64)),
                        (Value::Float(x), Value::Float(y)) => self.stack.push(Value::Float(x - y)),
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "two numbers (int or float)".to_string(), 
                            got: format!("{:?}, {:?}", a, b), 
                            operation: "SUB".to_string() 
                        }),
                    }
                }
                OpCode::Mul => {
                    let b = self.pop_stack("MUL")?;
                    let a = self.pop_stack("MUL")?;
                    match (&a, &b) {
                        (Value::Int(x), Value::Int(y)) => self.stack.push(Value::Int(x * y)),
                        (Value::Int(x), Value::Float(y)) => self.stack.push(Value::Float(*x as f64 * y)),
                        (Value::Float(x), Value::Int(y)) => self.stack.push(Value::Float(x * *y as f64)),
                        (Value::Float(x), Value::Float(y)) => self.stack.push(Value::Float(x * y)),
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "two numbers (int or float)".to_string(), 
                            got: format!("{:?}, {:?}", a, b), 
                            operation: "MUL".to_string() 
                        }),
                    }
                }
                OpCode::Div => {
                    let b = self.pop_stack("DIV")?;
                    let a = self.pop_stack("DIV")?;
                    match (&a, &b) {
                        (Value::Int(x), Value::Int(y)) => {
                            if *y == 0 {
                                return Err(VMError::DivisionByZero);
                            }
                            self.stack.push(Value::Int(x / y));
                        },
                        (Value::Int(x), Value::Float(y)) => {
                            if *y == 0.0 {
                                return Err(VMError::DivisionByZero);
                            }
                            self.stack.push(Value::Float(*x as f64 / y));
                        },
                        (Value::Float(x), Value::Int(y)) => {
                            if *y == 0 {
                                return Err(VMError::DivisionByZero);
                            }
                            self.stack.push(Value::Float(x / *y as f64));
                        },
                        (Value::Float(x), Value::Float(y)) => {
                            if *y == 0.0 {
                                return Err(VMError::DivisionByZero);
                            }
                            self.stack.push(Value::Float(x / y));
                        },
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "two numbers (int or float)".to_string(), 
                            got: format!("{:?}, {:?}", a, b), 
                            operation: "DIV".to_string() 
                        }),
                    }
                }
                OpCode::Dup => {
                    let val = self.peek_stack("DUP")?.clone();
                    self.stack.push(val);
                }
                OpCode::Store(name) => {
                    let val = self.pop_stack("STORE")?;
                    self.set_variable(name.clone(), val)?;
                }
                OpCode::Load(name) => {
                    let val = self.get_variable(&name)?;
                    self.stack.push(val);
                }
                OpCode::Delete(name) => {
                    let removed = self
                        .variables
                        .last_mut()
                        .ok_or(VMError::NoVariableScope)?
                        .remove(name);
                    if removed.is_none() {
                        eprintln!("Warning: tried to DELETE unknown variable '{}'", name);
                    }
                }
                OpCode::Eq => {
                    let b = self.pop_stack("EQ")?;
                    let a = self.pop_stack("EQ")?;
                    let result = match (&a, &b) {
                        (Value::Int(x), Value::Int(y)) => x == y,
                        (Value::Float(x), Value::Float(y)) => (x - y).abs() < f64::EPSILON,
                        (Value::Str(x), Value::Str(y)) => x == y,
                        (Value::Bool(x), Value::Bool(y)) => x == y,
                        (Value::Null, Value::Null) => true,
                        (Value::Function { addr: addr1, params: params1 }, Value::Function { addr: addr2, params: params2 }) => {
                            addr1 == addr2 && params1 == params2
                        },
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "values of the same type".to_string(), 
                            got: format!("{:?}, {:?}", a, b), 
                            operation: "EQ".to_string() 
                        }),
                    };
                    self.stack.push(Value::Int(if result { 1 } else { 0 }));
                }
                OpCode::Gt => {
                    let b = self.pop_stack("GT")?;
                    let a = self.pop_stack("GT")?;
                    match (&a, &b) {
                        (Value::Int(x), Value::Int(y)) => {
                            self.stack.push(Value::Int(if x > y { 1 } else { 0 }));
                        }
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "two integers".to_string(), 
                            got: format!("{:?}, {:?}", a, b), 
                            operation: "GT".to_string() 
                        }),
                    }
                }
                OpCode::Lt => {
                    let b = self.pop_stack("LT")?;
                    let a = self.pop_stack("LT")?;
                    match (&a, &b) {
                        (Value::Int(x), Value::Int(y)) => {
                            self.stack.push(Value::Int(if x < y { 1 } else { 0 }));
                        }
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "two integers".to_string(), 
                            got: format!("{:?}, {:?}", a, b), 
                            operation: "LT".to_string() 
                        }),
                    }
                }
                OpCode::Ne => {
                    let b = self.pop_stack("NE")?;
                    let a = self.pop_stack("NE")?;
                    let result = match (&a, &b) {
                        (Value::Int(x), Value::Int(y)) => x != y,
                        (Value::Float(x), Value::Float(y)) => (x - y).abs() >= f64::EPSILON,
                        (Value::Str(x), Value::Str(y)) => x != y,
                        (Value::Bool(x), Value::Bool(y)) => x != y,
                        (Value::Null, Value::Null) => false,
                        (Value::Function { addr: addr1, params: params1 }, Value::Function { addr: addr2, params: params2 }) => {
                            addr1 != addr2 || params1 != params2
                        },
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "values of the same type".to_string(), 
                            got: format!("{:?}, {:?}", a, b), 
                            operation: "NE".to_string() 
                        }),
                    };
                    self.stack.push(Value::Int(if result { 1 } else { 0 }));
                }
                OpCode::Ge => {
                    let b = self.pop_stack("GE")?;
                    let a = self.pop_stack("GE")?;
                    match (&a, &b) {
                        (Value::Int(x), Value::Int(y)) => {
                            self.stack.push(Value::Int(if x >= y { 1 } else { 0 }));
                        }
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "two integers".to_string(), 
                            got: format!("{:?}, {:?}", a, b), 
                            operation: "GE".to_string() 
                        }),
                    }
                }
                OpCode::Le => {
                    let b = self.pop_stack("LE")?;
                    let a = self.pop_stack("LE")?;
                    match (&a, &b) {
                        (Value::Int(x), Value::Int(y)) => {
                            self.stack.push(Value::Int(if x <= y { 1 } else { 0 }));
                        }
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "two integers".to_string(), 
                            got: format!("{:?}, {:?}", a, b), 
                            operation: "LE".to_string() 
                        }),
                    }
                }
                OpCode::EqF => {
                    let b = self.pop_stack("EQ_F")?;
                    let a = self.pop_stack("EQ_F")?;
                    match (&a, &b) {
                        (Value::Float(x), Value::Float(y)) => {
                            self.stack.push(Value::Int(if (x - y).abs() < f64::EPSILON { 1 } else { 0 }));
                        }
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "two floats".to_string(), 
                            got: format!("{:?}, {:?}", a, b), 
                            operation: "EQ_F".to_string() 
                        }),
                    }
                }
                OpCode::NeF => {
                    let b = self.pop_stack("NE_F")?;
                    let a = self.pop_stack("NE_F")?;
                    match (&a, &b) {
                        (Value::Float(x), Value::Float(y)) => {
                            self.stack.push(Value::Int(if (x - y).abs() >= f64::EPSILON { 1 } else { 0 }));
                        }
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "two floats".to_string(), 
                            got: format!("{:?}, {:?}", a, b), 
                            operation: "NE_F".to_string() 
                        }),
                    }
                }
                OpCode::GtF => {
                    let b = self.pop_stack("GT_F")?;
                    let a = self.pop_stack("GT_F")?;
                    match (&a, &b) {
                        (Value::Float(x), Value::Float(y)) => {
                            self.stack.push(Value::Int(if x > y { 1 } else { 0 }));
                        }
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "two floats".to_string(), 
                            got: format!("{:?}, {:?}", a, b), 
                            operation: "GT_F".to_string() 
                        }),
                    }
                }
                OpCode::LtF => {
                    let b = self.pop_stack("LT_F")?;
                    let a = self.pop_stack("LT_F")?;
                    match (&a, &b) {
                        (Value::Float(x), Value::Float(y)) => {
                            self.stack.push(Value::Int(if x < y { 1 } else { 0 }));
                        }
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "two floats".to_string(), 
                            got: format!("{:?}, {:?}", a, b), 
                            operation: "LT_F".to_string() 
                        }),
                    }
                }
                OpCode::GeF => {
                    let b = self.pop_stack("GE_F")?;
                    let a = self.pop_stack("GE_F")?;
                    match (&a, &b) {
                        (Value::Float(x), Value::Float(y)) => {
                            self.stack.push(Value::Int(if x >= y { 1 } else { 0 }));
                        }
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "two floats".to_string(), 
                            got: format!("{:?}, {:?}", a, b), 
                            operation: "GE_F".to_string() 
                        }),
                    }
                }
                OpCode::LeF => {
                    let b = self.pop_stack("LE_F")?;
                    let a = self.pop_stack("LE_F")?;
                    match (&a, &b) {
                        (Value::Float(x), Value::Float(y)) => {
                            self.stack.push(Value::Int(if x <= y { 1 } else { 0 }));
                        }
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "two floats".to_string(), 
                            got: format!("{:?}, {:?}", a, b), 
                            operation: "LE_F".to_string() 
                        }),
                    }
                }
                OpCode::True => self.stack.push(Value::Bool(true)),
                OpCode::False => self.stack.push(Value::Bool(false)),
                OpCode::Not => {
                    let val = self.pop_stack("NOT")?;
                    let result = match val {
                        Value::Bool(b) => !b,
                        Value::Int(i) => i == 0,
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "Bool or Int".to_string(), 
                            got: format!("{:?}", val), 
                            operation: "NOT".to_string() 
                        }),
                    };
                    self.stack.push(Value::Bool(result));
                }
                OpCode::And => {
                    let b = self.pop_stack("AND")?;
                    let a = self.pop_stack("AND")?;
                    let result = match (&a, &b) {
                        (Value::Bool(x), Value::Bool(y)) => *x && *y,
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "two Booleans".to_string(), 
                            got: format!("{:?}, {:?}", a, b), 
                            operation: "AND".to_string() 
                        }),
                    };
                    self.stack.push(Value::Bool(result));
                }
                OpCode::Or => {
                    let b = self.pop_stack("OR")?;
                    let a = self.pop_stack("OR")?;
                    let result = match (&a, &b) {
                        (Value::Bool(x), Value::Bool(y)) => *x || *y,
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "two Booleans".to_string(), 
                            got: format!("{:?}, {:?}", a, b), 
                            operation: "OR".to_string() 
                        }),
                    };
                    self.stack.push(Value::Bool(result));
                }
                OpCode::Null => {
                    self.stack.push(Value::Null);
                }
                OpCode::MakeList(n) => {
                    self.check_stack_size(*n, "MAKE_LIST")?;
                    let mut list = Vec::with_capacity(*n);
                    for _ in 0..*n {
                        list.push(self.pop_stack("MAKE_LIST")?);
                    }
                    list.reverse();
                    self.stack.push(Value::List(list));
                }
                OpCode::Len => {
                    let val = self.pop_stack("LEN")?;
                    match val {
                        Value::List(l) => self.stack.push(Value::Int(l.len() as i64)),
                        Value::Object(o) => self.stack.push(Value::Int(o.len() as i64)),
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "a list or object".to_string(), 
                            got: format!("{:?}", val), 
                            operation: "LEN".to_string() 
                        }),
                    }
                }
                OpCode::Index => {
                    let index = match self.pop_stack("INDEX")? {
                        Value::Int(i) => i as usize,
                        val => return Err(VMError::TypeMismatch { 
                            expected: "an integer index".to_string(), 
                            got: format!("{:?}", val), 
                            operation: "INDEX".to_string() 
                        }),
                    };
                    let list = match self.pop_stack("INDEX")? {
                        Value::List(l) => l,
                        val => return Err(VMError::TypeMismatch { 
                            expected: "a list".to_string(), 
                            got: format!("{:?}", val), 
                            operation: "INDEX".to_string() 
                        }),
                    };
                    if index >= list.len() {
                        return Err(VMError::IndexOutOfBounds { index, length: list.len() });
                    }
                    self.stack.push(list[index].clone());
                }
                OpCode::MakeObject => {
                    let obj = HashMap::new();
                    self.stack.push(Value::Object(obj));
                }
                OpCode::SetField(field_name) => {
                    let value = self.pop_stack("SET_FIELD")?;
                    let obj = self.pop_stack("SET_FIELD")?;
                    match obj {
                        Value::Object(mut map) => {
                            map.insert(field_name.clone(), value);
                            self.stack.push(Value::Object(map));
                        }
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "an object".to_string(), 
                            got: format!("{:?}", obj), 
                            operation: "SET_FIELD".to_string() 
                        }),
                    }
                }
                OpCode::GetField(field_name) => {
                    let obj = self.pop_stack("GET_FIELD")?;
                    match obj {
                        Value::Object(map) => {
                            let value = map.get(field_name).cloned().unwrap_or(Value::Null);
                            self.stack.push(value);
                        }
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "an object".to_string(), 
                            got: format!("{:?}", obj), 
                            operation: "GET_FIELD".to_string() 
                        }),
                    }
                }
                OpCode::HasField(field_name) => {
                    let obj = self.pop_stack("HAS_FIELD")?;
                    match obj {
                        Value::Object(map) => {
                            let has_field = map.contains_key(field_name);
                            self.stack.push(Value::Int(if has_field { 1 } else { 0 }));
                        }
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "an object".to_string(), 
                            got: format!("{:?}", obj), 
                            operation: "HAS_FIELD".to_string() 
                        }),
                    }
                }
                OpCode::DeleteField(field_name) => {
                    let obj = self.pop_stack("DELETE_FIELD")?;
                    match obj {
                        Value::Object(mut map) => {
                            map.remove(field_name);
                            self.stack.push(Value::Object(map));
                        }
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "an object".to_string(), 
                            got: format!("{:?}", obj), 
                            operation: "DELETE_FIELD".to_string() 
                        }),
                    }
                }
                OpCode::Keys => {
                    let obj = self.pop_stack("KEYS")?;
                    match obj {
                        Value::Object(map) => {
                            let keys: Vec<Value> = map.keys().map(|k| Value::Str(k.clone())).collect();
                            self.stack.push(Value::List(keys));
                        }
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "an object".to_string(), 
                            got: format!("{:?}", obj), 
                            operation: "KEYS".to_string() 
                        }),
                    }
                }
                OpCode::MakeFunction { addr, params } => {
                    let function = Value::Function { addr: *addr, params: params.clone() };
                    self.stack.push(function);
                }
                OpCode::MakeLambda { addr, params } => {
                    // Create closure with currently captured variables
                    let closure = Value::Closure { 
                        addr: *addr, 
                        params: params.clone(),
                        captured: self.lambda_captures.clone() 
                    };
                    self.stack.push(closure);
                    
                    // Clear captures for next lambda
                    self.lambda_captures.clear();
                }
                OpCode::Capture(var_name) => {
                    // Capture current value of variable for lambda
                    let value = self.get_variable(var_name)?.clone();
                    self.lambda_captures.insert(var_name.clone(), value);
                }
                OpCode::CallFunction => {
                    let function = self.pop_stack("CALL_FUNCTION")?;
                    match function {
                        Value::Function { addr, params } => {
                            // Check if we have enough arguments on the stack
                            self.check_stack_size(params.len(), "CALL_FUNCTION")?;
                            
                            // Save return address
                            self.call_stack.push(self.ip + 1);
                            
                            // Create new variable frame for function parameters
                            let mut frame = HashMap::new();
                            for name in params.iter().rev() {
                                let value = self.pop_stack("CALL_FUNCTION")?;
                                frame.insert(name.clone(), value);
                            }
                            self.variables.push(frame);
                            
                            // Jump to function
                            self.ip = addr;
                        }
                        Value::Closure { addr, params, captured } => {
                            // Check if we have enough arguments on the stack
                            self.check_stack_size(params.len(), "CALL_FUNCTION")?;
                            
                            // Save return address
                            self.call_stack.push(self.ip + 1);
                            
                            // Create new variable frame with captured variables and parameters
                            let mut frame = captured; // Start with captured environment
                            for name in params.iter().rev() {
                                let value = self.pop_stack("CALL_FUNCTION")?;
                                frame.insert(name.clone(), value); // Parameters override captured vars
                            }
                            self.variables.push(frame);
                            
                            // Jump to closure body
                            self.ip = addr;
                        }
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "a function or closure".to_string(), 
                            got: format!("{:?}", function), 
                            operation: "CALL_FUNCTION".to_string() 
                        }),
                    }
                }
                OpCode::ReadFile => {
                    let val = self.pop_stack("READ_file")?;
                    match val {
                        Value::Str(filename) => {
                            match std::fs::read_to_string(&filename) {
                                Ok(content) => self.stack.push(Value::Str(content)),
                                Err(e) => return Err(VMError::FileError { 
                                    filename, 
                                    error: e.to_string() 
                                }),
                            }
                        }
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "a string filename".to_string(), 
                            got: format!("{:?}", val), 
                            operation: "READ_FILE".to_string() 
                        }),
                    }
                }
                OpCode::WriteFile => {
                    let filename = self.pop_stack("WRITE_FILE")?;
                    let content = self.pop_stack("WRITE_FILE")?;
                    match (filename, content) {
                        (Value::Str(fname), Value::Str(body)) => {
                            if let Err(e) = std::fs::write(&fname, &body) {
                                return Err(VMError::FileError { 
                                    filename: fname, 
                                    error: e.to_string() 
                                });
                            }
                        }
                        (f, c) => return Err(VMError::TypeMismatch { 
                            expected: "two strings (filename, content)".to_string(), 
                            got: format!("{:?}, {:?}", f, c), 
                            operation: "WRITE_FILE".to_string() 
                        }),
                    }
                }
                // Enhanced I/O operations
                OpCode::ReadLine => {
                    use std::io::{self, BufRead};
                    let stdin = io::stdin();
                    let mut line = String::new();
                    match stdin.lock().read_line(&mut line) {
                        Ok(_) => {
                            // Remove trailing newline
                            if line.ends_with('\n') {
                                line.pop();
                                if line.ends_with('\r') {
                                    line.pop();
                                }
                            }
                            self.stack.push(Value::Str(line));
                        }
                        Err(e) => return Err(VMError::FileError { 
                            filename: "stdin".to_string(), 
                            error: e.to_string() 
                        }),
                    }
                }
                OpCode::ReadChar => {
                    use std::io::{self, Read};
                    let mut stdin = io::stdin();
                    let mut buffer = [0; 1];
                    match stdin.read_exact(&mut buffer) {
                        Ok(_) => {
                            let ch = buffer[0] as char;
                            self.stack.push(Value::Str(ch.to_string()));
                        }
                        Err(e) => return Err(VMError::FileError { 
                            filename: "stdin".to_string(), 
                            error: e.to_string() 
                        }),
                    }
                }
                OpCode::ReadInput => {
                    use std::io::{self, Read};
                    let mut stdin = io::stdin();
                    let mut buffer = String::new();
                    match stdin.read_to_string(&mut buffer) {
                        Ok(_) => self.stack.push(Value::Str(buffer)),
                        Err(e) => return Err(VMError::FileError { 
                            filename: "stdin".to_string(), 
                            error: e.to_string() 
                        }),
                    }
                }
                OpCode::AppendFile => {
                    let filename = self.pop_stack("APPEND_FILE")?;
                    let content = self.pop_stack("APPEND_FILE")?;
                    match (filename, content) {
                        (Value::Str(fname), Value::Str(body)) => {
                            use std::fs::OpenOptions;
                            use std::io::Write;
                            match OpenOptions::new().create(true).append(true).open(&fname) {
                                Ok(mut file) => {
                                    if let Err(e) = file.write_all(body.as_bytes()) {
                                        return Err(VMError::FileError { 
                                            filename: fname, 
                                            error: e.to_string() 
                                        });
                                    }
                                }
                                Err(e) => return Err(VMError::FileError { 
                                    filename: fname, 
                                    error: e.to_string() 
                                }),
                            }
                        }
                        (f, c) => return Err(VMError::TypeMismatch { 
                            expected: "two strings (filename, content)".to_string(), 
                            got: format!("{:?}, {:?}", f, c), 
                            operation: "APPEND_FILE".to_string() 
                        }),
                    }
                }
                OpCode::FileExists => {
                    let val = self.pop_stack("FILE_EXISTS")?;
                    match val {
                        Value::Str(filename) => {
                            let exists = std::path::Path::new(&filename).exists();
                            self.stack.push(Value::Bool(exists));
                        }
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "string (filename)".to_string(), 
                            got: format!("{:?}", val), 
                            operation: "FILE_EXISTS".to_string() 
                        }),
                    }
                }
                OpCode::FileSize => {
                    let val = self.pop_stack("FILE_SIZE")?;
                    match val {
                        Value::Str(filename) => {
                            match std::fs::metadata(&filename) {
                                Ok(metadata) => self.stack.push(Value::Int(metadata.len() as i64)),
                                Err(e) => return Err(VMError::FileError { 
                                    filename, 
                                    error: e.to_string() 
                                }),
                            }
                        }
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "string (filename)".to_string(), 
                            got: format!("{:?}", val), 
                            operation: "FILE_SIZE".to_string() 
                        }),
                    }
                }
                OpCode::DeleteFile => {
                    let val = self.pop_stack("DELETE_FILE")?;
                    match val {
                        Value::Str(filename) => {
                            match std::fs::remove_file(&filename) {
                                Ok(_) => {}
                                Err(e) => return Err(VMError::FileError { 
                                    filename, 
                                    error: e.to_string() 
                                }),
                            }
                        }
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "string (filename)".to_string(), 
                            got: format!("{:?}", val), 
                            operation: "DELETE_FILE".to_string() 
                        }),
                    }
                }
                OpCode::ListDir => {
                    let val = self.pop_stack("LIST_DIR")?;
                    match val {
                        Value::Str(dirname) => {
                            match std::fs::read_dir(&dirname) {
                                Ok(entries) => {
                                    let mut files = Vec::new();
                                    for entry in entries {
                                        match entry {
                                            Ok(entry) => {
                                                if let Some(name) = entry.file_name().to_str() {
                                                    files.push(Value::Str(name.to_string()));
                                                }
                                            }
                                            Err(e) => return Err(VMError::FileError { 
                                                filename: dirname, 
                                                error: e.to_string() 
                                            }),
                                        }
                                    }
                                    self.stack.push(Value::List(files));
                                }
                                Err(e) => return Err(VMError::FileError { 
                                    filename: dirname, 
                                    error: e.to_string() 
                                }),
                            }
                        }
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "string (directory name)".to_string(), 
                            got: format!("{:?}", val), 
                            operation: "LIST_DIR".to_string() 
                        }),
                    }
                }
                OpCode::ReadBytes => {
                    let val = self.pop_stack("READ_bytes")?;
                    match val {
                        Value::Str(filename) => {
                            match std::fs::read(&filename) {
                                Ok(bytes) => self.stack.push(Value::Bytes(bytes)),
                                Err(e) => return Err(VMError::FileError { 
                                    filename, 
                                    error: e.to_string() 
                                }),
                            }
                        }
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "string (filename)".to_string(), 
                            got: format!("{:?}", val), 
                            operation: "read_bytes".to_string() 
                        }),
                    }
                }
                OpCode::WriteBytes => {
                    let filename = self.pop_stack("WRITE_BYTES")?;
                    let content = self.pop_stack("WRITE_BYTES")?;
                    match (filename, content) {
                        (Value::Str(fname), Value::Bytes(bytes)) => {
                            if let Err(e) = std::fs::write(&fname, &bytes) {
                                return Err(VMError::FileError { 
                                    filename: fname, 
                                    error: e.to_string() 
                                });
                            }
                        }
                        (f, c) => return Err(VMError::TypeMismatch { 
                            expected: "string (filename) and bytes".to_string(), 
                            got: format!("{:?}, {:?}", f, c), 
                            operation: "WRITE_BYTES".to_string() 
                        }),
                    }
                }
                // Environment and system operations
                OpCode::GetEnv => {
                    let val = self.pop_stack("GET_ENV")?;
                    match val {
                        Value::Str(var_name) => {
                            match std::env::var(&var_name) {
                                Ok(value) => self.stack.push(Value::Str(value)),
                                Err(_) => self.stack.push(Value::Null),
                            }
                        }
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "string (variable name)".to_string(), 
                            got: format!("{:?}", val), 
                            operation: "GET_ENV".to_string() 
                        }),
                    }
                }
                OpCode::SetEnv => {
                    let value = self.pop_stack("SET_ENV")?;
                    let var_name = self.pop_stack("SET_ENV")?;
                    match (var_name, value) {
                        (Value::Str(name), Value::Str(val)) => {
                            std::env::set_var(&name, &val);
                        }
                        (n, v) => return Err(VMError::TypeMismatch { 
                            expected: "two strings (variable name, value)".to_string(), 
                            got: format!("{:?}, {:?}", n, v), 
                            operation: "SET_ENV".to_string() 
                        }),
                    }
                }
                OpCode::GetArgs => {
                    let args: Vec<Value> = std::env::args()
                        .map(|arg| Value::Str(arg))
                        .collect();
                    self.stack.push(Value::List(args));
                }
                OpCode::Exec => {
                    let args = self.pop_stack("EXEC")?;
                    let command = self.pop_stack("EXEC")?;
                    match (command, args) {
                        (Value::Str(cmd), Value::List(arg_list)) => {
                            use std::process::Command;
                            let mut cmd_obj = Command::new(&cmd);
                            for arg in arg_list {
                                if let Value::Str(arg_str) = arg {
                                    cmd_obj.arg(arg_str);
                                } else {
                                    return Err(VMError::TypeMismatch { 
                                        expected: "list of strings (arguments)".to_string(), 
                                        got: format!("{:?}", arg), 
                                        operation: "EXEC".to_string() 
                                    });
                                }
                            }
                            match cmd_obj.status() {
                                Ok(status) => {
                                    let exit_code = status.code().unwrap_or(-1);
                                    self.stack.push(Value::Int(exit_code as i64));
                                }
                                Err(e) => return Err(VMError::FileError { 
                                    filename: cmd, 
                                    error: e.to_string() 
                                }),
                            }
                        }
                        (c, a) => return Err(VMError::TypeMismatch { 
                            expected: "string (command) and list (arguments)".to_string(), 
                            got: format!("{:?}, {:?}", c, a), 
                            operation: "EXEC".to_string() 
                        }),
                    }
                }
                OpCode::ExecCapture => {
                    let args = self.pop_stack("EXEC_CAPTURE")?;
                    let command = self.pop_stack("EXEC_CAPTURE")?;
                    match (command, args) {
                        (Value::Str(cmd), Value::List(arg_list)) => {
                            use std::process::Command;
                            let mut cmd_obj = Command::new(&cmd);
                            for arg in arg_list {
                                if let Value::Str(arg_str) = arg {
                                    cmd_obj.arg(arg_str);
                                } else {
                                    return Err(VMError::TypeMismatch { 
                                        expected: "list of strings (arguments)".to_string(), 
                                        got: format!("{:?}", arg), 
                                        operation: "EXEC_CAPTURE".to_string() 
                                    });
                                }
                            }
                            match cmd_obj.output() {
                                Ok(output) => {
                                    let stdout = String::from_utf8_lossy(&output.stdout).to_string();
                                    let stderr = String::from_utf8_lossy(&output.stderr).to_string();
                                    let exit_code = output.status.code().unwrap_or(-1);
                                    
                                    // Create result object
                                    let mut result = HashMap::new();
                                    result.insert("stdout".to_string(), Value::Str(stdout));
                                    result.insert("stderr".to_string(), Value::Str(stderr));
                                    result.insert("exit_code".to_string(), Value::Int(exit_code as i64));
                                    self.stack.push(Value::Object(result));
                                }
                                Err(e) => return Err(VMError::FileError { 
                                    filename: cmd, 
                                    error: e.to_string() 
                                }),
                            }
                        }
                        (c, a) => return Err(VMError::TypeMismatch { 
                            expected: "string (command) and list (arguments)".to_string(), 
                            got: format!("{:?}, {:?}", c, a), 
                            operation: "EXEC_CAPTURE".to_string() 
                        }),
                    }
                }
                OpCode::Exit => {
                    let val = self.pop_stack("EXIT")?;
                    match val {
                        Value::Int(code) => {
                            std::process::exit(code as i32);
                        }
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "int (exit code)".to_string(), 
                            got: format!("{:?}", val), 
                            operation: "EXIT".to_string() 
                        }),
                    }
                }
                // Time operations
                OpCode::GetTime => {
                    use std::time::{SystemTime, UNIX_EPOCH};
                    match SystemTime::now().duration_since(UNIX_EPOCH) {
                        Ok(duration) => {
                            self.stack.push(Value::Int(duration.as_secs() as i64));
                        }
                        Err(e) => return Err(VMError::FileError { 
                            filename: "system_time".to_string(), 
                            error: e.to_string() 
                        }),
                    }
                }
                OpCode::Sleep => {
                    let val = self.pop_stack("SLEEP")?;
                    match val {
                        Value::Int(millis) => {
                            let duration = std::time::Duration::from_millis(millis as u64);
                            std::thread::sleep(duration);
                        }
                        Value::Float(millis) => {
                            let duration = std::time::Duration::from_millis(millis as u64);
                            std::thread::sleep(duration);
                        }
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "int or float (milliseconds)".to_string(), 
                            got: format!("{:?}", val), 
                            operation: "SLEEP".to_string() 
                        }),
                    }
                }
                OpCode::FormatTime => {
                    let format_str = self.pop_stack("FORMAT_TIME")?;
                    let timestamp = self.pop_stack("FORMAT_TIME")?;
                    match (timestamp, format_str) {
                        (Value::Int(ts), Value::Str(_format)) => {
                            // Simplified time formatting - just return ISO format
                            use std::time::UNIX_EPOCH;
                            let _system_time = UNIX_EPOCH + Duration::from_secs(ts as u64);
                            // For simplicity, just return the timestamp as string
                            // In a real implementation, we'd use chrono or similar for formatting
                            self.stack.push(Value::Str(format!("{}", ts)));
                        }
                        (t, f) => return Err(VMError::TypeMismatch { 
                            expected: "int (timestamp) and string (format)".to_string(), 
                            got: format!("{:?}, {:?}", t, f), 
                            operation: "FORMAT_TIME".to_string() 
                        }),
                    }
                }
                // Network operations
                OpCode::HttpGet => {
                    let val = self.pop_stack("HTTP_GET")?;
                    match val {
                        Value::Str(url) => {
                            // Simplified HTTP GET using std library (in real implementation would use reqwest)
                            // For now, just return a placeholder response
                            let response = format!("HTTP response from {}", url);
                            self.stack.push(Value::Str(response));
                        }
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "string (URL)".to_string(), 
                            got: format!("{:?}", val), 
                            operation: "HTTP_GET".to_string() 
                        }),
                    }
                }
                OpCode::HttpPost => {
                    let data = self.pop_stack("HTTP_POST")?;
                    let url = self.pop_stack("HTTP_POST")?;
                    match (url, data) {
                        (Value::Str(url_str), Value::Str(data_str)) => {
                            // Simplified HTTP POST (in real implementation would use reqwest)
                            let response = format!("HTTP POST to {} with data: {}", url_str, data_str);
                            self.stack.push(Value::Str(response));
                        }
                        (u, d) => return Err(VMError::TypeMismatch { 
                            expected: "two strings (URL, data)".to_string(), 
                            got: format!("{:?}, {:?}", u, d), 
                            operation: "HTTP_POST".to_string() 
                        }),
                    }
                }
                OpCode::TcpConnect => {
                    let port = self.pop_stack("TCP_CONNECT")?;
                    let host = self.pop_stack("TCP_CONNECT")?;
                    match (host, port) {
                        (Value::Str(host_str), Value::Int(port_num)) => {
                            // Simplified TCP connect - in real implementation would create actual socket
                            use std::net::TcpStream;
                            let address = format!("{}:{}", host_str, port_num);
                            match TcpStream::connect(&address) {
                                Ok(_stream) => {
                                    // In real implementation, we'd store the stream
                                    // For now, just return a connection ID
                                    let conn_id = format!("tcp://{}:{}", host_str, port_num);
                                    self.stack.push(Value::Connection(conn_id));
                                }
                                Err(e) => return Err(VMError::FileError { 
                                    filename: address, 
                                    error: e.to_string() 
                                }),
                            }
                        }
                        (h, p) => return Err(VMError::TypeMismatch { 
                            expected: "string (host) and int (port)".to_string(), 
                            got: format!("{:?}, {:?}", h, p), 
                            operation: "TCP_CONNECT".to_string() 
                        }),
                    }
                }
                OpCode::TcpListen => {
                    let val = self.pop_stack("TCP_LISTEN")?;
                    match val {
                        Value::Int(port) => {
                            // Simplified TCP listen - in real implementation would bind and listen
                            use std::net::TcpListener;
                            let address = format!("127.0.0.1:{}", port);
                            match TcpListener::bind(&address) {
                                Ok(_listener) => {
                                    // In real implementation, we'd store the listener
                                    let conn_id = format!("tcp://listener:{}", port);
                                    self.stack.push(Value::Connection(conn_id));
                                }
                                Err(e) => return Err(VMError::FileError { 
                                    filename: address, 
                                    error: e.to_string() 
                                }),
                            }
                        }
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "int (port)".to_string(), 
                            got: format!("{:?}", val), 
                            operation: "TCP_LISTEN".to_string() 
                        }),
                    }
                }
                OpCode::TcpSend => {
                    let data = self.pop_stack("TCP_SEND")?;
                    let conn = self.pop_stack("TCP_SEND")?;
                    match (conn, data) {
                        (Value::Connection(conn_id), Value::Str(data_str)) => {
                            // Simplified TCP send - in real implementation would send via actual socket
                            println!("TCP Send to {}: {}", conn_id, data_str);
                            self.stack.push(Value::Int(data_str.len() as i64));
                        }
                        (Value::Connection(conn_id), Value::Bytes(data_bytes)) => {
                            // Send binary data
                            println!("TCP Send to {}: {} bytes", conn_id, data_bytes.len());
                            self.stack.push(Value::Int(data_bytes.len() as i64));
                        }
                        (c, d) => return Err(VMError::TypeMismatch { 
                            expected: "connection and string/bytes".to_string(), 
                            got: format!("{:?}, {:?}", c, d), 
                            operation: "TCP_SEND".to_string() 
                        }),
                    }
                }
                OpCode::TcpRecv => {
                    let size = self.pop_stack("TCP_RECV")?;
                    let conn = self.pop_stack("TCP_RECV")?;
                    match (conn, size) {
                        (Value::Connection(conn_id), Value::Int(buffer_size)) => {
                            // Simplified TCP recv - in real implementation would receive from actual socket
                            let received_data = format!("Data from {}", conn_id);
                            if buffer_size > 0 {
                                self.stack.push(Value::Str(received_data));
                            } else {
                                self.stack.push(Value::Bytes(vec![1, 2, 3, 4])); // Mock binary data
                            }
                        }
                        (c, s) => return Err(VMError::TypeMismatch { 
                            expected: "connection and int (buffer size)".to_string(), 
                            got: format!("{:?}, {:?}", c, s), 
                            operation: "TCP_RECV".to_string() 
                        }),
                    }
                }
                OpCode::UdpBind => {
                    let val = self.pop_stack("UDP_BIND")?;
                    match val {
                        Value::Int(port) => {
                            // Simplified UDP bind - in real implementation would bind UDP socket
                            use std::net::UdpSocket;
                            let address = format!("127.0.0.1:{}", port);
                            match UdpSocket::bind(&address) {
                                Ok(_socket) => {
                                    let conn_id = format!("udp://bind:{}", port);
                                    self.stack.push(Value::Connection(conn_id));
                                }
                                Err(e) => return Err(VMError::FileError { 
                                    filename: address, 
                                    error: e.to_string() 
                                }),
                            }
                        }
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "int (port)".to_string(), 
                            got: format!("{:?}", val), 
                            operation: "UDP_BIND".to_string() 
                        }),
                    }
                }
                OpCode::UdpSend => {
                    let data = self.pop_stack("UDP_SEND")?;
                    let port = self.pop_stack("UDP_SEND")?;
                    let host = self.pop_stack("UDP_SEND")?;
                    let socket = self.pop_stack("UDP_SEND")?;
                    match (socket, host, port, data) {
                        (Value::Connection(conn_id), Value::Str(host_str), Value::Int(port_num), Value::Str(data_str)) => {
                            // Simplified UDP send
                            println!("UDP Send from {} to {}:{}: {}", conn_id, host_str, port_num, data_str);
                            self.stack.push(Value::Int(data_str.len() as i64));
                        }
                        (s, h, p, d) => return Err(VMError::TypeMismatch { 
                            expected: "connection, string (host), int (port), string (data)".to_string(), 
                            got: format!("{:?}, {:?}, {:?}, {:?}", s, h, p, d), 
                            operation: "UDP_SEND".to_string() 
                        }),
                    }
                }
                OpCode::UdpRecv => {
                    let size = self.pop_stack("UDP_RECV")?;
                    let socket = self.pop_stack("UDP_RECV")?;
                    match (socket, size) {
                        (Value::Connection(_conn_id), Value::Int(_buffer_size)) => {
                            // Simplified UDP recv - return mock data and sender info
                            let mut result = HashMap::new();
                            result.insert("data".to_string(), Value::Str("UDP packet data".to_string()));
                            result.insert("sender_host".to_string(), Value::Str("192.168.1.100".to_string()));
                            result.insert("sender_port".to_string(), Value::Int(12345));
                            self.stack.push(Value::Object(result));
                        }
                        (s, sz) => return Err(VMError::TypeMismatch { 
                            expected: "connection and int (buffer size)".to_string(), 
                            got: format!("{:?}, {:?}", s, sz), 
                            operation: "UDP_RECV".to_string() 
                        }),
                    }
                }
                OpCode::DnsResolve => {
                    let val = self.pop_stack("DNS_RESOLVE")?;
                    match val {
                        Value::Str(hostname) => {
                            // Simplified DNS resolution using std library
                            use std::net::ToSocketAddrs;
                            let address_with_port = format!("{}:80", hostname); // Add dummy port for resolution
                            match address_with_port.to_socket_addrs() {
                                Ok(mut addrs) => {
                                    if let Some(addr) = addrs.next() {
                                        let ip = addr.ip().to_string();
                                        self.stack.push(Value::Str(ip));
                                    } else {
                                        self.stack.push(Value::Null);
                                    }
                                }
                                Err(_) => {
                                    // Return mock IP for demonstration
                                    self.stack.push(Value::Str("192.168.1.1".to_string()));
                                }
                            }
                        }
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "string (hostname)".to_string(), 
                            got: format!("{:?}", val), 
                            operation: "DNS_RESOLVE".to_string() 
                        }),
                    }
                }
                // Advanced I/O operations
                OpCode::AsyncRead => {
                    let val = self.pop_stack("ASYNC_READ")?;
                    match val {
                        Value::Str(filename) => {
                            // Simplified async read - in real implementation would use tokio or async-std
                            let future_id = format!("async_read:{}", filename);
                            self.stack.push(Value::Future(future_id));
                        }
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "string (filename)".to_string(), 
                            got: format!("{:?}", val), 
                            operation: "ASYNC_READ".to_string() 
                        }),
                    }
                }
                OpCode::AsyncWrite => {
                    let filename = self.pop_stack("ASYNC_WRITE")?;
                    let content = self.pop_stack("ASYNC_WRITE")?;
                    match (filename, content) {
                        (Value::Str(fname), Value::Str(data)) => {
                            // Simplified async write - encode filename and content in future ID
                            let future_id = format!("async_write:{}:{}", fname, data);
                            self.stack.push(Value::Future(future_id));
                        }
                        (f, c) => return Err(VMError::TypeMismatch { 
                            expected: "string (filename) and string (content)".to_string(), 
                            got: format!("{:?}, {:?}", f, c), 
                            operation: "ASYNC_WRITE".to_string() 
                        }),
                    }
                }
                OpCode::Await => {
                    let val = self.pop_stack("AWAIT")?;
                    match val {
                        Value::Future(future_id) => {
                            // Simplified await - simulate completion
                            if future_id.starts_with("async_read:") {
                                let filename = future_id.strip_prefix("async_read:").unwrap_or("unknown");
                                // Simulate reading file
                                match std::fs::read_to_string(filename) {
                                    Ok(content) => self.stack.push(Value::Str(content)),
                                    Err(e) => return Err(VMError::FileError { 
                                        filename: filename.to_string(), 
                                        error: e.to_string() 
                                    }),
                                }
                            } else if future_id.starts_with("async_write:") {
                                // Parse the async_write future format: "async_write:filename:content"
                                let content_part = future_id.strip_prefix("async_write:").unwrap_or("");
                                if let Some(separator_index) = content_part.find(':') {
                                    let filename = &content_part[..separator_index];
                                    let data = &content_part[separator_index + 1..];
                                    match std::fs::write(filename, data) {
                                        Ok(()) => self.stack.push(Value::Bool(true)),
                                        Err(e) => return Err(VMError::FileError { 
                                            filename: filename.to_string(), 
                                            error: e.to_string() 
                                        }),
                                    }
                                } else {
                                    self.stack.push(Value::Bool(true));
                                }
                            } else {
                                self.stack.push(Value::Null);
                            }
                        }
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "future".to_string(), 
                            got: format!("{:?}", val), 
                            operation: "AWAIT".to_string() 
                        }),
                    }
                }
                OpCode::StreamCreate => {
                    let val = self.pop_stack("STREAM_CREATE")?;
                    match val {
                        Value::Str(stream_type) => {
                            let stream_id = format!("stream:{}:{}", stream_type, self.instruction_count);
                            self.stack.push(Value::Stream(stream_id));
                        }
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "string (stream type)".to_string(), 
                            got: format!("{:?}", val), 
                            operation: "STREAM_CREATE".to_string() 
                        }),
                    }
                }
                OpCode::StreamRead => {
                    let size = self.pop_stack("STREAM_READ")?;
                    let stream = self.pop_stack("STREAM_READ")?;
                    match (stream, size) {
                        (Value::Stream(_stream_id), Value::Int(read_size)) => {
                            // Simplified stream read
                            let data = format!("stream_data_{}", read_size);
                            self.stack.push(Value::Str(data));
                        }
                        (s, sz) => return Err(VMError::TypeMismatch { 
                            expected: "stream and int (size)".to_string(), 
                            got: format!("{:?}, {:?}", s, sz), 
                            operation: "STREAM_READ".to_string() 
                        }),
                    }
                }
                OpCode::StreamWrite => {
                    let data = self.pop_stack("STREAM_WRITE")?;
                    let stream = self.pop_stack("STREAM_WRITE")?;
                    match (stream, data) {
                        (Value::Stream(_stream_id), Value::Str(write_data)) => {
                            // Simplified stream write
                            self.stack.push(Value::Int(write_data.len() as i64));
                        }
                        (Value::Stream(_stream_id), Value::Bytes(write_bytes)) => {
                            // Write binary data to stream
                            self.stack.push(Value::Int(write_bytes.len() as i64));
                        }
                        (s, d) => return Err(VMError::TypeMismatch { 
                            expected: "stream and string/bytes".to_string(), 
                            got: format!("{:?}, {:?}", s, d), 
                            operation: "STREAM_WRITE".to_string() 
                        }),
                    }
                }
                OpCode::StreamClose => {
                    let val = self.pop_stack("STREAM_CLOSE")?;
                    match val {
                        Value::Stream(_stream_id) => {
                            // Simplified stream close
                            self.stack.push(Value::Bool(true));
                        }
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "stream".to_string(), 
                            got: format!("{:?}", val), 
                            operation: "STREAM_CLOSE".to_string() 
                        }),
                    }
                }
                OpCode::JsonParse => {
                    let val = self.pop_stack("JSON_PARSE")?;
                    match val {
                        Value::Str(json_str) => {
                            // Simplified JSON parsing - in real implementation would use serde_json
                            if json_str.starts_with('{') && json_str.ends_with('}') {
                                let mut obj = HashMap::new();
                                obj.insert("parsed".to_string(), Value::Bool(true));
                                obj.insert("data".to_string(), Value::Str("json_data".to_string()));
                                self.stack.push(Value::Object(obj));
                            } else if json_str.starts_with('[') && json_str.ends_with(']') {
                                let list = vec![
                                    Value::Str("item1".to_string()),
                                    Value::Str("item2".to_string()),
                                ];
                                self.stack.push(Value::List(list));
                            } else {
                                self.stack.push(Value::Str(json_str));
                            }
                        }
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "string (JSON)".to_string(), 
                            got: format!("{:?}", val), 
                            operation: "JSON_PARSE".to_string() 
                        }),
                    }
                }
                OpCode::JsonStringify => {
                    let val = self.pop_stack("JSON_STRINGIFY")?;
                    match val {
                        Value::Object(_) => {
                            // Simplified JSON stringification
                            self.stack.push(Value::Str("{\"key\":\"value\"}".to_string()));
                        }
                        Value::List(_) => {
                            self.stack.push(Value::Str("[\"item1\",\"item2\"]".to_string()));
                        }
                        Value::Str(s) => {
                            self.stack.push(Value::Str(format!("\"{}\"", s)));
                        }
                        Value::Int(n) => {
                            self.stack.push(Value::Str(n.to_string()));
                        }
                        Value::Bool(b) => {
                            self.stack.push(Value::Str(b.to_string()));
                        }
                        Value::Null => {
                            self.stack.push(Value::Str("null".to_string()));
                        }
                        _ => {
                            self.stack.push(Value::Str("{}".to_string()));
                        }
                    }
                }
                OpCode::CsvParse => {
                    let val = self.pop_stack("CSV_PARSE")?;
                    match val {
                        Value::Str(csv_str) => {
                            // Simplified CSV parsing
                            let rows: Vec<Value> = csv_str.lines()
                                .map(|line| {
                                    let columns: Vec<Value> = line.split(',')
                                        .map(|col| Value::Str(col.trim().to_string()))
                                        .collect();
                                    Value::List(columns)
                                })
                                .collect();
                            self.stack.push(Value::List(rows));
                        }
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "string (CSV)".to_string(), 
                            got: format!("{:?}", val), 
                            operation: "CSV_PARSE".to_string() 
                        }),
                    }
                }
                OpCode::CsvWrite => {
                    let val = self.pop_stack("CSV_WRITE")?;
                    match val {
                        Value::List(rows) => {
                            // Simplified CSV writing
                            let mut csv_output = String::new();
                            for (i, row) in rows.iter().enumerate() {
                                if i > 0 {
                                    csv_output.push('\n');
                                }
                                if let Value::List(columns) = row {
                                    for (j, col) in columns.iter().enumerate() {
                                        if j > 0 {
                                            csv_output.push(',');
                                        }
                                        csv_output.push_str(&format!("{}", col));
                                    }
                                }
                            }
                            self.stack.push(Value::Str(csv_output));
                        }
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "list of lists (CSV data)".to_string(), 
                            got: format!("{:?}", val), 
                            operation: "CSV_WRITE".to_string() 
                        }),
                    }
                }
                OpCode::Compress => {
                    let val = self.pop_stack("COMPRESS")?;
                    match val {
                        Value::Str(data) => {
                            // Simplified compression - in real implementation would use flate2
                            let compressed = format!("compressed({})", data.len());
                            self.stack.push(Value::Bytes(compressed.into_bytes()));
                        }
                        Value::Bytes(data) => {
                            let compressed = format!("compressed({})", data.len());
                            self.stack.push(Value::Bytes(compressed.into_bytes()));
                        }
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "string or bytes".to_string(), 
                            got: format!("{:?}", val), 
                            operation: "COMPRESS".to_string() 
                        }),
                    }
                }
                OpCode::Decompress => {
                    let val = self.pop_stack("DECOMPRESS")?;
                    match val {
                        Value::Bytes(data) => {
                            // Simplified decompression
                            let decompressed = format!("decompressed:{}", String::from_utf8_lossy(&data));
                            self.stack.push(Value::Str(decompressed));
                        }
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "bytes (compressed data)".to_string(), 
                            got: format!("{:?}", val), 
                            operation: "DECOMPRESS".to_string() 
                        }),
                    }
                }
                OpCode::Encrypt => {
                    let key = self.pop_stack("ENCRYPT")?;
                    let data = self.pop_stack("ENCRYPT")?;
                    match (data, key) {
                        (Value::Str(plaintext), Value::Str(encryption_key)) => {
                            // Simplified encryption - in real implementation would use proper crypto
                            let encrypted = format!("encrypted:{}:key:{}", plaintext.len(), encryption_key.len());
                            self.stack.push(Value::Bytes(encrypted.into_bytes()));
                        }
                        (d, k) => return Err(VMError::TypeMismatch { 
                            expected: "string (data) and string (key)".to_string(), 
                            got: format!("{:?}, {:?}", d, k), 
                            operation: "ENCRYPT".to_string() 
                        }),
                    }
                }
                OpCode::Decrypt => {
                    let key = self.pop_stack("DECRYPT")?;
                    let data = self.pop_stack("DECRYPT")?;
                    match (data, key) {
                        (Value::Bytes(ciphertext), Value::Str(_decryption_key)) => {
                            // Simplified decryption
                            let decrypted = format!("decrypted:{}", String::from_utf8_lossy(&ciphertext));
                            self.stack.push(Value::Str(decrypted));
                        }
                        (d, k) => return Err(VMError::TypeMismatch { 
                            expected: "bytes (encrypted data) and string (key)".to_string(), 
                            got: format!("{:?}, {:?}", d, k), 
                            operation: "DECRYPT".to_string() 
                        }),
                    }
                }
                OpCode::Hash => {
                    let val = self.pop_stack("HASH")?;
                    match val {
                        Value::Str(data) => {
                            // Simplified hashing - in real implementation would use sha2, md5, etc.
                            use std::collections::hash_map::DefaultHasher;
                            use std::hash::{Hash, Hasher};
                            let mut hasher = DefaultHasher::new();
                            data.hash(&mut hasher);
                            let hash_value = hasher.finish();
                            self.stack.push(Value::Str(format!("{:x}", hash_value)));
                        }
                        Value::Bytes(data) => {
                            use std::collections::hash_map::DefaultHasher;
                            use std::hash::{Hash, Hasher};
                            let mut hasher = DefaultHasher::new();
                            data.hash(&mut hasher);
                            let hash_value = hasher.finish();
                            self.stack.push(Value::Str(format!("{:x}", hash_value)));
                        }
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "string or bytes".to_string(), 
                            got: format!("{:?}", val), 
                            operation: "HASH".to_string() 
                        }),
                    }
                }
                OpCode::DbConnect => {
                    let val = self.pop_stack("DB_CONNECT")?;
                    match val {
                        Value::Str(connection_string) => {
                            // Simplified database connection - in real implementation would use sqlx, rusqlite, etc.
                            let db_id = format!("db:{}", connection_string);
                            self.stack.push(Value::Connection(db_id));
                        }
                        _ => return Err(VMError::TypeMismatch { 
                            expected: "string (connection string)".to_string(), 
                            got: format!("{:?}", val), 
                            operation: "DB_CONNECT".to_string() 
                        }),
                    }
                }
                OpCode::DbQuery => {
                    let query = self.pop_stack("DB_QUERY")?;
                    let db = self.pop_stack("DB_QUERY")?;
                    match (db, query) {
                        (Value::Connection(_db_id), Value::Str(_sql_query)) => {
                            // Simplified database query
                            let mut result = HashMap::new();
                            result.insert("rows".to_string(), Value::Int(3));
                            result.insert("columns".to_string(), Value::List(vec![
                                Value::Str("id".to_string()),
                                Value::Str("name".to_string()),
                            ]));
                            result.insert("data".to_string(), Value::List(vec![
                                Value::List(vec![Value::Int(1), Value::Str("Alice".to_string())]),
                                Value::List(vec![Value::Int(2), Value::Str("Bob".to_string())]),
                                Value::List(vec![Value::Int(3), Value::Str("Charlie".to_string())]),
                            ]));
                            self.stack.push(Value::Object(result));
                        }
                        (d, q) => return Err(VMError::TypeMismatch { 
                            expected: "connection and string (SQL query)".to_string(), 
                            got: format!("{:?}, {:?}", d, q), 
                            operation: "DB_QUERY".to_string() 
                        }),
                    }
                }
                OpCode::DbExec => {
                    let command = self.pop_stack("DB_EXEC")?;
                    let db = self.pop_stack("DB_EXEC")?;
                    match (db, command) {
                        (Value::Connection(_db_id), Value::Str(_sql_command)) => {
                            // Simplified database execution
                            self.stack.push(Value::Int(1)); // affected rows
                        }
                        (d, c) => return Err(VMError::TypeMismatch { 
                            expected: "connection and string (SQL command)".to_string(), 
                            got: format!("{:?}, {:?}", d, c), 
                            operation: "DB_EXEC".to_string() 
                        }),
                    }
                }
                OpCode::DumpScope => {
                    println!("Current scope: {:?}", self.variables.last());
                }
                // Exception handling opcodes
                OpCode::Try { catch_addr } => {
                    self.push_exception_handler(*catch_addr);
                }
                OpCode::Catch => {
                    // The exception should already be on the stack from throw_exception
                    // Nothing to do here, just mark that we're in the catch block
                }
                OpCode::Throw => {
                    let exception_value = self.pop_stack("THROW")?;
                    
                    // Convert value to exception if it's not already one
                    let exception = match exception_value {
                        Value::Exception { .. } => exception_value,
                        Value::Str(msg) => Value::Exception { 
                            message: msg,
                            stack_trace: vec![format!("at instruction {}", self.ip)]
                        },
                        other => Value::Exception {
                            message: format!("Thrown value: {:?}", other),
                            stack_trace: vec![format!("at instruction {}", self.ip)]
                        }
                    };
                    
                    self.throw_exception(exception)?;
                }
                OpCode::EndTry => {
                    // Pop the exception handler when exiting try block normally
                    self.pop_exception_handler();
                }
                OpCode::Import(path) => {
                    self.import_module(path)?;
                }
                OpCode::Export(name) => {
                    self.export_symbol(name)?;
                }
                OpCode::Spawn => {
                    // For VM struct, not supported (use TinyProc instead)
                    return Err(VMError::UnsupportedOperation("SPAWN not supported in VM, use TinyProc scheduler".to_string()));
                }
                OpCode::Receive => {
                    // For VM struct, not supported (use TinyProc instead)
                    return Err(VMError::UnsupportedOperation("RECEIVE not supported in VM, use TinyProc scheduler".to_string()));
                }
                OpCode::Yield => {
                    // For VM struct, not supported (use TinyProc instead)
                    return Err(VMError::UnsupportedOperation("YIELD not supported in VM, use TinyProc scheduler".to_string()));
                }
                OpCode::Send(_proc_id) => {
                    // For VM struct, not supported (use TinyProc instead)
                    return Err(VMError::UnsupportedOperation("SEND not supported in VM, use TinyProc scheduler".to_string()));
                }
                OpCode::Monitor(_proc_id) => {
                    // For VM struct, not supported (use TinyProc instead)
                    return Err(VMError::UnsupportedOperation("MONITOR not supported in VM, use TinyProc scheduler".to_string()));
                }
                OpCode::Demonitor(_monitor_ref) => {
                    // For VM struct, not supported (use TinyProc instead)
                    return Err(VMError::UnsupportedOperation("DEMONITOR not supported in VM, use TinyProc scheduler".to_string()));
                }
                OpCode::Link(_proc_id) => {
                    // For VM struct, not supported (use TinyProc instead)
                    return Err(VMError::UnsupportedOperation("LINK not supported in VM, use TinyProc scheduler".to_string()));
                }
                OpCode::Unlink(_proc_id) => {
                    // For VM struct, not supported (use TinyProc instead)
                    return Err(VMError::UnsupportedOperation("UNLINK not supported in VM, use TinyProc scheduler".to_string()));
                }
                OpCode::TrapExit => {
                    // For VM struct, not supported (use TinyProc instead)
                    return Err(VMError::UnsupportedOperation("TRAP_EXIT not supported in VM, use TinyProc scheduler".to_string()));
                }
                OpCode::ReceiveMatch(_patterns) => {
                    // For VM struct, not supported (use TinyProc instead)
                    return Err(VMError::UnsupportedOperation("RECEIVE_MATCH not supported in VM, use TinyProc scheduler".to_string()));
                }
                OpCode::Register(_name) => {
                    // For VM struct, not supported (use TinyProc instead)
                    return Err(VMError::UnsupportedOperation("REGISTER not supported in VM, use TinyProc scheduler".to_string()));
                }
                OpCode::Unregister(_name) => {
                    // For VM struct, not supported (use TinyProc instead)
                    return Err(VMError::UnsupportedOperation("UNREGISTER not supported in VM, use TinyProc scheduler".to_string()));
                }
                OpCode::Whereis(_name) => {
                    // For VM struct, not supported (use TinyProc instead)
                    return Err(VMError::UnsupportedOperation("WHEREIS not supported in VM, use TinyProc scheduler".to_string()));
                }
                OpCode::SendNamed(_name) => {
                    // For VM struct, not supported (use TinyProc instead)
                    return Err(VMError::UnsupportedOperation("SENDNAMED not supported in VM, use TinyProc scheduler".to_string()));
                }
                OpCode::StartSupervisor => {
                    // For VM struct, not supported (use TinyProc instead)
                    return Err(VMError::UnsupportedOperation("STARTSUPERVISOR not supported in VM, use TinyProc scheduler".to_string()));
                }
                OpCode::SuperviseChild(_name) => {
                    // For VM struct, not supported (use TinyProc instead)
                    return Err(VMError::UnsupportedOperation("SUPERVISECHILD not supported in VM, use TinyProc scheduler".to_string()));
                }
                OpCode::RestartChild(_name) => {
                    // For VM struct, not supported (use TinyProc instead)
                    return Err(VMError::UnsupportedOperation("RESTARTCHILD not supported in VM, use TinyProc scheduler".to_string()));
                }
                OpCode::Halt => {
                    // This should never be reached since HALT is handled in run()
                    unreachable!("HALT instruction should be handled in run() method")
                }
            }
            Ok(())
        }

    fn import_module(&mut self, path: &str) -> VMResult<()> {
        // Check for circular dependencies using global loading stack
        if self.loading_stack.contains(&path.to_string()) {
            return Err(VMError::FileError {
                filename: path.to_string(),
                error: "Circular dependency detected".to_string(),
            });
        }

        // Check if module is already loaded
        if let Some(exports) = self.loaded_modules.get(path).cloned() {
            // Module already loaded, import its exports into current scope
            for (name, value) in exports {
                self.set_variable(name, value)?;
            }
            return Ok(());
        }

        // Add to loading stack to detect circular dependencies
        self.loading_stack.push(path.to_string());

        // Load and parse the module
        let module_instructions = parse_program(path)?;
        
        // Merge module instructions into main VM's instruction space
        let base_addr = self.instructions.len();
        let mut adjusted_exports = HashMap::new();
        
        // Adjust addresses in module instructions and append to main instruction space
        let adjusted_instructions = module_instructions.iter()
            .map(|inst| self.adjust_instruction_addresses(inst, base_addr))
            .collect::<Vec<_>>();
        self.instructions.extend(adjusted_instructions);
        
        // Create a new VM with the module instructions to get exports
        // Share the loading context to detect circular dependencies
        let mut module_vm = VM::new(module_instructions);
        module_vm.debug_mode = self.debug_mode;
        module_vm.loading_stack = self.loading_stack.clone(); // Share loading context
        module_vm.loaded_modules = self.loaded_modules.clone(); // Share loaded modules
        
        // Run the module to generate exports
        module_vm.run()?;
        
        // Update our loaded modules with any new modules the sub-module loaded
        self.loaded_modules.extend(module_vm.loaded_modules);
        
        // Adjust function addresses in exports to point to merged instruction space
        for (name, value) in module_vm.exports {
            let adjusted_value = self.adjust_value_addresses(value, base_addr);
            adjusted_exports.insert(name, adjusted_value);
        }
        
        // Cache the loaded module
        self.loaded_modules.insert(path.to_string(), adjusted_exports.clone());
        
        // Import the exports into current scope
        if self.debug_mode {
            println!("Importing {} exports from module {}", adjusted_exports.len(), path);
        }
        for (name, value) in adjusted_exports {
            if self.debug_mode {
                println!("Importing export: {} = {:?}", name, value);
            }
            self.set_variable(name, value)?;
        }
        
        // Remove from loading stack
        self.loading_stack.pop();
        
        Ok(())
    }

    fn export_symbol(&mut self, name: &str) -> VMResult<()> {
        // Get the value from current scope
        let value = self.get_variable(name)?.clone();
        
        // Add to exports
        self.exports.insert(name.to_string(), value);
        
        Ok(())
    }

    fn adjust_value_addresses(&self, value: Value, base_addr: usize) -> Value {
        match value {
            Value::Function { addr, params } => {
                Value::Function { 
                    addr: addr + base_addr,
                    params 
                }
            }
            Value::Closure { addr, params, captured } => {
                // Recursively adjust addresses in captured environment
                let adjusted_captured = captured.into_iter()
                    .map(|(name, val)| (name, self.adjust_value_addresses(val, base_addr)))
                    .collect();
                
                Value::Closure { 
                    addr: addr + base_addr,
                    params,
                    captured: adjusted_captured
                }
            }
            Value::List(items) => {
                let adjusted_items = items.into_iter()
                    .map(|item| self.adjust_value_addresses(item, base_addr))
                    .collect();
                Value::List(adjusted_items)
            }
            Value::Object(map) => {
                let adjusted_map = map.into_iter()
                    .map(|(key, val)| (key, self.adjust_value_addresses(val, base_addr)))
                    .collect();
                Value::Object(adjusted_map)
            }
            // Other value types don't contain addresses
            other => other
        }
    }

    fn adjust_instruction_addresses(&self, instruction: &OpCode, base_addr: usize) -> OpCode {
        match instruction {
            OpCode::Jmp(addr) => OpCode::Jmp(addr + base_addr),
            OpCode::Jz(addr) => OpCode::Jz(addr + base_addr),
            OpCode::Call { addr, params } => OpCode::Call { 
                addr: addr + base_addr, 
                params: params.clone() 
            },
            OpCode::MakeFunction { addr, params } => OpCode::MakeFunction { 
                addr: addr + base_addr, 
                params: params.clone() 
            },
            OpCode::MakeLambda { addr, params } => OpCode::MakeLambda { 
                addr: addr + base_addr, 
                params: params.clone() 
            },
            OpCode::Try { catch_addr } => OpCode::Try { 
                catch_addr: catch_addr + base_addr 
            },
            // All other instructions don't contain addresses
            other => other.clone()
        }
    }
}

fn parse_program(path: &str) -> VMResult<Vec<OpCode>> {
    let content = fs::read_to_string(path).map_err(|e| VMError::FileError { 
        filename: path.to_string(), 
        error: e.to_string() 
    })?;

    let mut label_map: HashMap<String, usize> = HashMap::new();
    let mut instructions_raw: Vec<(usize, &str)> = Vec::new();

    // First pass: build label -> index map
    for (line_num, line) in content.lines().enumerate() {
        let line = line.split(';').next().unwrap_or("").trim();
        if line.is_empty() {
            continue;
        }
        if line.starts_with("LABEL ") {
            let label_name = line[6..].trim();
            label_map.insert(label_name.to_string(), instructions_raw.len());
        } else {
            instructions_raw.push((line_num + 1, line)); // save for second pass
        }
    }

    // Second pass: convert raw instructions to OpCode using label map
    let mut program: Vec<OpCode> = Vec::new();
    for (line_num, line) in instructions_raw {
        let parts: Vec<&str> = line.splitn(2, ' ').collect();
        let opcode = match parts[0] {
            "PUSH_INT" => {
                let n = parts[1].parse::<i64>().map_err(|_| VMError::ParseError { 
                    line: line_num, 
                    instruction: format!("Invalid integer: {}", parts[1]) 
                })?;
                OpCode::PushInt(n)
            }
            "PUSH_FLOAT" => {
                let f = parts[1].parse::<f64>().map_err(|_| VMError::ParseError { 
                    line: line_num, 
                    instruction: format!("Invalid float: {}", parts[1]) 
                })?;
                OpCode::PushFloat(f)
            }
            "PUSH_STR" => {
                let s = parts[1].trim_matches('"').to_string();
                OpCode::PushStr(s)
            }
            "PUSH_BOOL" => {
                let b = parts[1].parse::<bool>().map_err(|_| VMError::ParseError { 
                    line: line_num, 
                    instruction: format!("Invalid boolean: {}", parts[1]) 
                })?;
                OpCode::PushBool(b)
            }
            "ADD" => OpCode::Add,
            "ADD_F" => OpCode::AddF,
            "SUB" => OpCode::Sub,
            "SUB_F" => OpCode::SubF,
            "MUL" => OpCode::Mul,
            "MUL_F" => OpCode::MulF,
            "DIV" => OpCode::Div,
            "DIV_F" => OpCode::DivF,
            "DUP" => OpCode::Dup,
            "CONCAT" => OpCode::Concat,
            "PRINT" => OpCode::Print,
            "HALT" => OpCode::Halt,
            "CALL" => {
                if parts.len() < 2 {
                    return Err(VMError::ParseError { line: line_num, instruction: "CALL requires at least a target".to_string() });
                }
                let call_parts: Vec<&str> = parts[1].split_whitespace().collect();
                let label = call_parts[0];
                let params: Vec<String> = call_parts[1..].iter().map(|s| s.to_string()).collect();
                
                // Try parsing as number first, then as label
                let target = if let Ok(addr) = label.parse::<usize>() {
                    addr
                } else {
                    *label_map.get(label).ok_or_else(|| VMError::UnknownLabel(label.to_string()))?
                };
                OpCode::Call { addr: target, params }
            }
            "JMP" => {
                let label = parts[1].trim();
                let target = if let Ok(addr) = label.parse::<usize>() {
                    addr
                } else {
                    *label_map.get(label).ok_or_else(|| VMError::UnknownLabel(label.to_string()))?
                };
                OpCode::Jmp(target)
            }
            "JZ" => {
                let label = parts[1].trim();
                let target = if let Ok(addr) = label.parse::<usize>() {
                    addr
                } else {
                    *label_map.get(label).ok_or_else(|| VMError::UnknownLabel(label.to_string()))?
                };
                OpCode::Jz(target)
            }
            "RET" => OpCode::Ret,
            "STORE" => {
                let var = parts[1].trim().to_string();
                OpCode::Store(var)
            }
            "DELETE" => {
                let var = parts[1].trim().to_string();
                OpCode::Delete(var)
            }
            "LOAD" => {
                let var = parts[1].trim().to_string();
                OpCode::Load(var)
            }
            "EQ" => OpCode::Eq,
            "GT" => OpCode::Gt,
            "LT" => OpCode::Lt,
            "NE" => OpCode::Ne,
            "GE" => OpCode::Ge,
            "LE" => OpCode::Le,
            "EQ_F" => OpCode::EqF,
            "GT_F" => OpCode::GtF,
            "LT_F" => OpCode::LtF,
            "NE_F" => OpCode::NeF,
            "GE_F" => OpCode::GeF,
            "LE_F" => OpCode::LeF,
            "TRUE" => OpCode::True,
            "FALSE" => OpCode::False,
            "NOT" => OpCode::Not,
            "AND" => OpCode::And,
            "OR" => OpCode::Or,
            "NULL" => OpCode::Null,
            "MAKE_LIST" => {
                let n = parts[1].parse::<usize>().map_err(|_| VMError::ParseError { 
                    line: line_num, 
                    instruction: format!("Invalid list size: {}", parts[1]) 
                })?;
                OpCode::MakeList(n)
            }
            "LEN" => OpCode::Len,
            "INDEX" => OpCode::Index,
            "DUMP_SCOPE" => OpCode::DumpScope,
            "MAKE_OBJECT" => OpCode::MakeObject,
            "SET_FIELD" => {
                let field = parts[1].trim().to_string();
                OpCode::SetField(field)
            }
            "GET_FIELD" => {
                let field = parts[1].trim().to_string();
                OpCode::GetField(field)
            }
            "HAS_FIELD" => {
                let field = parts[1].trim().to_string();
                OpCode::HasField(field)
            }
            "DELETE_FIELD" => {
                let field = parts[1].trim().to_string();
                OpCode::DeleteField(field)
            }
            "KEYS" => OpCode::Keys,
            "MAKE_FUNCTION" => {
                if parts.len() < 2 {
                    return Err(VMError::ParseError { line: line_num, instruction: "MAKE_FUNCTION requires at least a target".to_string() });
                }
                let func_parts: Vec<&str> = parts[1].split_whitespace().collect();
                let label = func_parts[0];
                let params: Vec<String> = func_parts[1..].iter().map(|s| s.to_string()).collect();
                
                // Try parsing as number first, then as label
                let addr = if let Ok(address) = label.parse::<usize>() {
                    address
                } else {
                    *label_map.get(label).ok_or_else(|| VMError::UnknownLabel(label.to_string()))?
                };
                OpCode::MakeFunction { addr, params }
            }
            "CALL_FUNCTION" => OpCode::CallFunction,
            "MAKE_LAMBDA" => {
                if parts.len() < 2 {
                    return Err(VMError::ParseError { line: line_num, instruction: line.to_string() });
                }
                
                let remaining_parts: Vec<&str> = parts[1].split_whitespace().collect();
                if remaining_parts.is_empty() {
                    return Err(VMError::ParseError { line: line_num, instruction: line.to_string() });
                }
                
                let label = remaining_parts[0];
                let params = remaining_parts[1..].iter().map(|s| s.to_string()).collect();
                
                let addr = if let Ok(addr) = label.parse::<usize>() {
                    addr
                } else {
                    *label_map.get(label).ok_or_else(|| VMError::UnknownLabel(label.to_string()))?
                };
                OpCode::MakeLambda { addr, params }
            }
            "CAPTURE" => {
                let var = parts[1].trim().to_string();
                OpCode::Capture(var)
            }
            "TRY" => {
                let catch_label = parts[1].trim();
                let catch_addr = *label_map.get(catch_label).ok_or_else(|| VMError::UnknownLabel(catch_label.to_string()))?;
                OpCode::Try { catch_addr }
            }
            "CATCH" => OpCode::Catch,
            "THROW" => OpCode::Throw,
            "END_TRY" => OpCode::EndTry,
            "READ_FILE" => OpCode::ReadFile,
            "WRITE_FILE" => OpCode::WriteFile,
            // Enhanced I/O operations
            "READ_LINE" => OpCode::ReadLine,
            "READ_CHAR" => OpCode::ReadChar,
            "READ_INPUT" => OpCode::ReadInput,
            "APPEND_FILE" => OpCode::AppendFile,
            "FILE_EXISTS" => OpCode::FileExists,
            "FILE_SIZE" => OpCode::FileSize,
            "DELETE_FILE" => OpCode::DeleteFile,
            "LIST_DIR" => OpCode::ListDir,
            "READ_BYTES" => OpCode::ReadBytes,
            "WRITE_BYTES" => OpCode::WriteBytes,
            // Environment and system
            "GET_ENV" => OpCode::GetEnv,
            "SET_ENV" => OpCode::SetEnv,
            "GET_ARGS" => OpCode::GetArgs,
            "EXEC" => OpCode::Exec,
            "EXEC_CAPTURE" => OpCode::ExecCapture,
            "EXIT" => OpCode::Exit,
            // Time operations
            "GET_TIME" => OpCode::GetTime,
            "SLEEP" => OpCode::Sleep,
            "FORMAT_TIME" => OpCode::FormatTime,
            // Network operations
            "HTTP_GET" => OpCode::HttpGet,
            "HTTP_POST" => OpCode::HttpPost,
            "TCP_CONNECT" => OpCode::TcpConnect,
            "TCP_LISTEN" => OpCode::TcpListen,
            "TCP_SEND" => OpCode::TcpSend,
            "TCP_RECV" => OpCode::TcpRecv,
            "UDP_BIND" => OpCode::UdpBind,
            "UDP_SEND" => OpCode::UdpSend,
            "UDP_RECV" => OpCode::UdpRecv,
            "DNS_RESOLVE" => OpCode::DnsResolve,
            // Advanced I/O operations
            "ASYNC_READ" => OpCode::AsyncRead,
            "ASYNC_WRITE" => OpCode::AsyncWrite,
            "AWAIT" => OpCode::Await,
            "STREAM_CREATE" => OpCode::StreamCreate,
            "STREAM_READ" => OpCode::StreamRead,
            "STREAM_WRITE" => OpCode::StreamWrite,
            "STREAM_CLOSE" => OpCode::StreamClose,
            "JSON_PARSE" => OpCode::JsonParse,
            "JSON_STRINGIFY" => OpCode::JsonStringify,
            "CSV_PARSE" => OpCode::CsvParse,
            "CSV_WRITE" => OpCode::CsvWrite,
            "COMPRESS" => OpCode::Compress,
            "DECOMPRESS" => OpCode::Decompress,
            "ENCRYPT" => OpCode::Encrypt,
            "DECRYPT" => OpCode::Decrypt,
            "HASH" => OpCode::Hash,
            "DB_CONNECT" => OpCode::DbConnect,
            "DB_QUERY" => OpCode::DbQuery,
            "DB_EXEC" => OpCode::DbExec,
            "IMPORT" => {
                let path = parts[1].trim();
                // Remove quotes if present
                let path = if path.starts_with('"') && path.ends_with('"') {
                    path[1..path.len()-1].to_string()
                } else {
                    path.to_string()
                };
                OpCode::Import(path)
            }
            "EXPORT" => {
                let name = parts[1].trim().to_string();
                OpCode::Export(name)
            }
            "YIELD" => OpCode::Yield,
            "RECEIVE" => OpCode::Receive,
            "SEND" => {
                let pid = parts[1].parse::<u64>().map_err(|_| VMError::ParseError { 
                    line: line_num, 
                    instruction: format!("Invalid PID: {}", parts[1]) 
                })?;
                OpCode::Send(pid)
            }
            "REGISTER" => {
                let name = parts[1].trim_matches('"').to_string();
                OpCode::Register(name)
            }
            "WHEREIS" => {
                let name = parts[1].trim_matches('"').to_string();
                OpCode::Whereis(name)
            }
            "SPAWN" => OpCode::Spawn,
            "SENDNAMED" => {
                let name = parts[1].trim_matches('"').to_string();
                OpCode::SendNamed(name)
            }
            "UNREGISTER" => {
                let name = parts[1].trim_matches('"').to_string();
                OpCode::Unregister(name)
            }
            "TRAP_EXIT" => OpCode::TrapExit,
            "START_SUPERVISOR" => OpCode::StartSupervisor,
            "SUPERVISE_CHILD" => {
                let name = parts[1].trim_matches('"').to_string();
                OpCode::SuperviseChild(name)
            }
            "RESTART_CHILD" => {
                let name = parts[1].trim_matches('"').to_string();
                OpCode::RestartChild(name)
            }
            "LINK" => {
                let pid = parts[1].parse::<u64>().map_err(|_| VMError::ParseError { 
                    line: line_num, 
                    instruction: format!("Invalid PID: {}", parts[1]) 
                })?;
                OpCode::Link(pid)
            }
            "UNLINK" => {
                let pid = parts[1].parse::<u64>().map_err(|_| VMError::ParseError { 
                    line: line_num, 
                    instruction: format!("Invalid PID: {}", parts[1]) 
                })?;
                OpCode::Unlink(pid)
            }
            "MONITOR" => {
                let pid = parts[1].parse::<u64>().map_err(|_| VMError::ParseError { 
                    line: line_num, 
                    instruction: format!("Invalid PID: {}", parts[1]) 
                })?;
                OpCode::Monitor(pid)
            }
            "DEMONITOR" => {
                let monitor_ref = parts[1].trim_matches('"').to_string();
                OpCode::Demonitor(monitor_ref)
            }
            _ => return Err(VMError::ParseError { line: line_num, instruction: line.to_string() }),
        };
        program.push(opcode);
    }

    Ok(program)
}

fn optimize_program(input_file: &str, output_file: &str) {
    let program = match parse_program(input_file) {
        Ok(p) => p,
        Err(e) => {
            eprintln!("Parse error: {}", e);
            std::process::exit(1);
        }
    };

    let mut optimizer = optimizer::Optimizer::new(optimizer::OptimizationOptions::default());
    let analysis_before = optimizer.analyze_program(&program);
    
    println!("=== Program Analysis (Before Optimization) ===");
    println!("Total instructions: {}", analysis_before.total_instructions);
    println!("Constants: {}", analysis_before.constant_count);
    println!("Function calls: {}", analysis_before.call_count);
    println!("Memory operations: {}", analysis_before.memory_op_count);
    println!("Jumps: {}", analysis_before.jump_count);
    println!();

    let (optimized_program, stats) = optimizer.optimize(program);
    let analysis_after = optimizer.analyze_program(&optimized_program);

    println!("=== Optimization Results ===");
    println!("Instructions: {} -> {} ({})", 
        analysis_before.total_instructions, 
        analysis_after.total_instructions,
        analysis_before.total_instructions as i32 - analysis_after.total_instructions as i32);
    println!("Constants folded: {}", stats.constants_folded);
    println!("Dead instructions removed: {}", stats.dead_instructions_removed);
    println!("Tail calls optimized: {}", stats.tail_calls_optimized);
    println!("Memory operations optimized: {}", stats.memory_operations_optimized);
    println!("Peephole optimizations: {}", stats.peephole_optimizations_applied);
    println!("Constants propagated: {}", stats.constants_propagated);
    println!("Instructions combined: {}", stats.instructions_combined);
    println!("Jumps threaded: {}", stats.jumps_threaded);
    println!();

    // Write optimized program to file
    match write_optimized_program(&optimized_program, output_file) {
        Ok(_) => println!("Optimized program written to {}", output_file),
        Err(e) => {
            eprintln!("Failed to write optimized program: {}", e);
            std::process::exit(1);
        }
    }
}

fn write_optimized_program(program: &[OpCode], output_file: &str) -> std::io::Result<()> {
    let mut output = String::new();
    
    for (_i, instruction) in program.iter().enumerate() {
        let line = match instruction {
            OpCode::PushInt(n) => format!("PUSH_INT {}", n),
            OpCode::PushFloat(f) => format!("PUSH_FLOAT {}", f),
            OpCode::PushStr(s) => format!("PUSH_STR \"{}\"", s.replace("\"", "\\\"")),
            OpCode::PushBool(b) => format!("PUSH_BOOL {}", b),
            OpCode::Add => "ADD".to_string(),
            OpCode::AddF => "ADD_F".to_string(),
            OpCode::Sub => "SUB".to_string(),
            OpCode::SubF => "SUB_F".to_string(),
            OpCode::Mul => "MUL".to_string(),
            OpCode::MulF => "MUL_F".to_string(),
            OpCode::Div => "DIV".to_string(),
            OpCode::DivF => "DIV_F".to_string(),
            OpCode::Concat => "CONCAT".to_string(),
            OpCode::Print => "PRINT".to_string(),
            OpCode::Halt => "HALT".to_string(),
            OpCode::Jmp(addr) => format!("JMP {}", addr),
            OpCode::Jz(addr) => format!("JZ {}", addr),
            OpCode::Call { addr, params } => format!("CALL {} {}", addr, params.join(" ")),
            OpCode::Ret => "RET".to_string(),
            OpCode::Dup => "DUP".to_string(),
            OpCode::Store(var) => format!("STORE {}", var),
            OpCode::Load(var) => format!("LOAD {}", var),
            OpCode::Delete(var) => format!("DELETE {}", var),
            OpCode::Eq => "EQ".to_string(),
            OpCode::Ne => "NE".to_string(),
            OpCode::Gt => "GT".to_string(),
            OpCode::Lt => "LT".to_string(),
            OpCode::Ge => "GE".to_string(),
            OpCode::Le => "LE".to_string(),
            OpCode::EqF => "EQ_F".to_string(),
            OpCode::NeF => "NE_F".to_string(),
            OpCode::GtF => "GT_F".to_string(),
            OpCode::LtF => "LT_F".to_string(),
            OpCode::GeF => "GE_F".to_string(),
            OpCode::LeF => "LE_F".to_string(),
            OpCode::True => "TRUE".to_string(),
            OpCode::False => "FALSE".to_string(),
            OpCode::Not => "NOT".to_string(),
            OpCode::And => "AND".to_string(),
            OpCode::Or => "OR".to_string(),
            OpCode::Null => "NULL".to_string(),
            OpCode::MakeList(n) => format!("MAKE_LIST {}", n),
            OpCode::Len => "LEN".to_string(),
            OpCode::Index => "INDEX".to_string(),
            OpCode::DumpScope => "DUMP_SCOPE".to_string(),
            OpCode::ReadFile => "READ_FILE".to_string(),
            OpCode::WriteFile => "WRITE_FILE".to_string(),
            // Enhanced I/O operations
            OpCode::ReadLine => "READ_LINE".to_string(),
            OpCode::ReadChar => "READ_CHAR".to_string(),
            OpCode::ReadInput => "READ_INPUT".to_string(),
            OpCode::AppendFile => "APPEND_FILE".to_string(),
            OpCode::FileExists => "FILE_EXISTS".to_string(),
            OpCode::FileSize => "FILE_SIZE".to_string(),
            OpCode::DeleteFile => "DELETE_FILE".to_string(),
            OpCode::ListDir => "LIST_DIR".to_string(),
            OpCode::ReadBytes => "READ_BYTES".to_string(),
            OpCode::WriteBytes => "WRITE_BYTES".to_string(),
            // Environment and system
            OpCode::GetEnv => "GET_ENV".to_string(),
            OpCode::SetEnv => "SET_ENV".to_string(),
            OpCode::GetArgs => "GET_ARGS".to_string(),
            OpCode::Exec => "EXEC".to_string(),
            OpCode::ExecCapture => "EXEC_CAPTURE".to_string(),
            OpCode::Exit => "EXIT".to_string(),
            // Time operations
            OpCode::GetTime => "GET_TIME".to_string(),
            OpCode::Sleep => "SLEEP".to_string(),
            OpCode::FormatTime => "FORMAT_TIME".to_string(),
            // Network operations
            OpCode::HttpGet => "HTTP_GET".to_string(),
            OpCode::HttpPost => "HTTP_POST".to_string(),
            OpCode::TcpConnect => "TCP_CONNECT".to_string(),
            OpCode::TcpListen => "TCP_LISTEN".to_string(),
            OpCode::TcpSend => "TCP_SEND".to_string(),
            OpCode::TcpRecv => "TCP_RECV".to_string(),
            OpCode::UdpBind => "UDP_BIND".to_string(),
            OpCode::UdpSend => "UDP_SEND".to_string(),
            OpCode::UdpRecv => "UDP_RECV".to_string(),
            OpCode::DnsResolve => "DNS_RESOLVE".to_string(),
            // Advanced I/O operations
            OpCode::AsyncRead => "ASYNC_READ".to_string(),
            OpCode::AsyncWrite => "ASYNC_WRITE".to_string(),
            OpCode::Await => "AWAIT".to_string(),
            OpCode::StreamCreate => "STREAM_CREATE".to_string(),
            OpCode::StreamRead => "STREAM_READ".to_string(),
            OpCode::StreamWrite => "STREAM_WRITE".to_string(),
            OpCode::StreamClose => "STREAM_CLOSE".to_string(),
            OpCode::JsonParse => "JSON_PARSE".to_string(),
            OpCode::JsonStringify => "JSON_STRINGIFY".to_string(),
            OpCode::CsvParse => "CSV_PARSE".to_string(),
            OpCode::CsvWrite => "CSV_WRITE".to_string(),
            OpCode::Compress => "COMPRESS".to_string(),
            OpCode::Decompress => "DECOMPRESS".to_string(),
            OpCode::Encrypt => "ENCRYPT".to_string(),
            OpCode::Decrypt => "DECRYPT".to_string(),
            OpCode::Hash => "HASH".to_string(),
            OpCode::DbConnect => "DB_CONNECT".to_string(),
            OpCode::DbQuery => "DB_QUERY".to_string(),
            OpCode::DbExec => "DB_EXEC".to_string(),
            OpCode::MakeObject => "MAKE_OBJECT".to_string(),
            OpCode::SetField(field) => format!("SET_FIELD {}", field),
            OpCode::GetField(field) => format!("GET_FIELD {}", field),
            OpCode::HasField(field) => format!("HAS_FIELD {}", field),
            OpCode::DeleteField(field) => format!("DELETE_FIELD {}", field),
            OpCode::Keys => "KEYS".to_string(),
            OpCode::MakeFunction { addr, params } => format!("MAKE_FUNCTION {} {}", addr, params.join(" ")),
            OpCode::CallFunction => "CALL_FUNCTION".to_string(),
            OpCode::MakeLambda { addr, params } => format!("MAKE_LAMBDA {} {}", addr, params.join(" ")),
            OpCode::Capture(var) => format!("CAPTURE {}", var),
            OpCode::Try { catch_addr } => format!("TRY {}", catch_addr),
            OpCode::Catch => "CATCH".to_string(),
            OpCode::Throw => "THROW".to_string(),
            OpCode::EndTry => "END_TRY".to_string(),
            OpCode::Import(path) => format!("IMPORT {}", path),
            OpCode::Export(name) => format!("EXPORT {}", name),
            OpCode::Spawn => format!("SPAWN"),
            OpCode::Receive => format!("RECEIVE"),
            OpCode::ReceiveMatch(_patterns) => format!("RECEIVE_MATCH"),
            OpCode::Yield => format!("YIELD"),
            OpCode::Send(proc_id) => format!("SEND {}", proc_id),
            OpCode::Monitor(proc_id) => format!("MONITOR {}", proc_id),
            OpCode::Demonitor(monitor_ref) => format!("DEMONITOR {}", monitor_ref),
            OpCode::Link(proc_id) => format!("LINK {}", proc_id),
            OpCode::Unlink(proc_id) => format!("UNLINK {}", proc_id),
            OpCode::TrapExit => "TRAP_EXIT".to_string(),
            OpCode::Register(name) => format!("REGISTER {}", name),
            OpCode::Unregister(name) => format!("UNREGISTER {}", name),
            OpCode::Whereis(name) => format!("WHEREIS {}", name),
            OpCode::SendNamed(name) => format!("SENDNAMED {}", name),
            OpCode::StartSupervisor => "STARTSUPERVISOR".to_string(),
            OpCode::SuperviseChild(name) => format!("SUPERVISECHILD {}", name),
            OpCode::RestartChild(name) => format!("RESTARTCHILD {}", name),
        };
        output.push_str(&line);
        output.push('\n');
    }
    
    std::fs::write(output_file, output)
}

fn run_smp_test(program: Vec<OpCode>) -> Result<(), Box<dyn std::error::Error>> {
    // Create SMP scheduler pool with reduced verbosity for testing
    let mut scheduler_pool = SchedulerPool::new_with_default_threads();
    
    // Spawn the main process with the program
    let (_main_proc_id, _main_sender) = scheduler_pool.spawn_process(program);
    
    // Run the scheduler pool
    scheduler_pool.run()?;
    
    // Wait for schedulers to finish
    scheduler_pool.wait_for_completion();
    
    Ok(())
}

fn run_comprehensive_tests() {
    use std::path::Path;
    use std::io::Write;
    
    println!("=== TinyTotVM Comprehensive Test Suite ===");
    println!();
    
    // Automatically discover all .ttvm files in the examples directory
    let examples_dir = Path::new("examples");
    let mut test_files = Vec::new();
    
    if examples_dir.exists() && examples_dir.is_dir() {
        match fs::read_dir(examples_dir) {
            Ok(entries) => {
                for entry in entries {
                    if let Ok(entry) = entry {
                        let path = entry.path();
                        if let Some(extension) = path.extension() {
                            if extension == "ttvm" {
                                if let Some(filename) = path.file_name() {
                                    if let Some(filename_str) = filename.to_str() {
                                        test_files.push(filename_str.to_string());
                                    }
                                }
                            }
                        }
                    }
                }
            }
            Err(e) => {
                eprintln!("Error reading examples directory: {}", e);
                return;
            }
        }
    } else {
        eprintln!("Examples directory not found!");
        return;
    }
    
    // Sort test files for consistent ordering
    test_files.sort();
    
    println!("Found {} test files in examples directory", test_files.len());
    println!();
    
    let mut passed = 0;
    let mut failed = 0;
    let mut skipped = 0;
    
    let mut results = Vec::new();
    
    // Tests that are expected to fail with specific error messages
    let expected_failures = std::collections::HashMap::from([
        ("circular_a.ttvm", "Circular dependency detected"),
        ("circular_b.ttvm", "Circular dependency detected"),
    ]);
    
    // Files that require concurrency features (should be run with SMP)
    let concurrency_files = std::collections::HashSet::from([
        "01_process_spawning.ttvm",
        "02_message_passing.ttvm", 
        "03_name_registry.ttvm",
        "04_comprehensive_workflow.ttvm",
        "05_trap_exit_test.ttvm",
        "06_supervisor_test.ttvm",
        "07_process_linking_test.ttvm",
        "08_selective_receive_test.ttvm",
        "09_process_registry_test.ttvm",
        "10_comprehensive_concurrency_test.ttvm",
        "coffee_shop_demo.ttvm",
        "concurrency_test.ttvm",
        "simple_concurrency_demo.ttvm",
        "simple_registry_test.ttvm",
        "simple_trap_exit_test.ttvm",
        "spawn_simple_worker.ttvm",
        "spawn_test.ttvm",
        "test_spawn.ttvm",
        "test_sendnamed.ttvm",
        "test_examples.ttvm",
        "working_beam_example.ttvm",
        "working_example.ttvm",
        "barista_worker.ttvm",
        "cashier_worker.ttvm",
        "simple_worker_test.ttvm",
    ]);
    
    for filename in &test_files {
        let path = format!("examples/{}", filename);
        
        if !Path::new(&path).exists() {
            println!("SKIP: {} (file not found)", filename);
            skipped += 1;
            results.push(TestResult {
                name: filename.to_string(),
                expected: "File exists".to_string(),
                actual: "File not found".to_string(),
                passed: false,
            });
            continue;
        }
        
        // Determine if this test should use SMP scheduler
        let use_smp = concurrency_files.contains(filename.as_str());
        let test_mode = if use_smp { "SMP" } else { "Regular" };
        
        print!("Testing {} ({}): ", filename, test_mode);
        Write::flush(&mut std::io::stdout()).unwrap();
        
        // Parse and run the test
        match parse_program(&path) {
            Ok(program) => {
                let test_result = if use_smp {
                    // Run with SMP scheduler
                    run_smp_test(program)
                } else {
                    // Run with regular VM
                    let mut vm = VM::new(program);
                    vm.run().map_err(|e| Box::new(e) as Box<dyn std::error::Error>)
                };
                
                match test_result {
                    Ok(()) => {
                        // Check if this test was expected to fail
                        if let Some(expected_error) = expected_failures.get(filename.as_str()) {
                            println!("FAIL: Expected error '{}' but test passed", expected_error);
                            failed += 1;
                            results.push(TestResult {
                                name: format!("{} ({})", filename, test_mode),
                                expected: format!("Error: {}", expected_error),
                                actual: "Success".to_string(),
                                passed: false,
                            });
                        } else {
                            println!("PASS");
                            passed += 1;
                            results.push(TestResult {
                                name: format!("{} ({})", filename, test_mode),
                                expected: "Success".to_string(),
                                actual: "Success".to_string(),
                                passed: true,
                            });
                        }
                    }
                    Err(e) => {
                        let error_msg = e.to_string();
                        // Check if this is an expected failure
                        if let Some(expected_error) = expected_failures.get(filename.as_str()) {
                            if error_msg.contains(expected_error) {
                                println!("PASS (Expected failure)");
                                passed += 1;
                                results.push(TestResult {
                                    name: format!("{} ({})", filename, test_mode),
                                    expected: format!("Error: {}", expected_error),
                                    actual: format!("Error: {}", error_msg),
                                    passed: true,
                                });
                            } else {
                                println!("FAIL: Expected '{}' but got '{}'", expected_error, error_msg);
                                failed += 1;
                                results.push(TestResult {
                                    name: format!("{} ({})", filename, test_mode),
                                    expected: format!("Error: {}", expected_error),
                                    actual: format!("Error: {}", error_msg),
                                    passed: false,
                                });
                            }
                        } else {
                            println!("FAIL: {}", e);
                            failed += 1;
                            results.push(TestResult {
                                name: format!("{} ({})", filename, test_mode),
                                expected: "Success".to_string(),
                                actual: format!("Error: {}", e),
                                passed: false,
                            });
                        }
                    }
                }
            }
            Err(e) => {
                println!("FAIL: Parse error: {}", e);
                failed += 1;
                results.push(TestResult {
                    name: filename.to_string(),
                    expected: "Success".to_string(),
                    actual: format!("Parse error: {}", e),
                    passed: false,
                });
            }
        }
    }
    
    println!();
    println!("{}", "═══ Test Summary ═══".bright_cyan().bold());
    
    // Create a table for the summary
    let mut table = Table::new();
    table.load_preset(UTF8_FULL)
         .apply_modifier(UTF8_SOLID_INNER_BORDERS);
    table.set_header(vec![
        Cell::new("Result").add_attribute(Attribute::Bold).fg(Color::Cyan),
        Cell::new("Count").add_attribute(Attribute::Bold).fg(Color::White),
    ]);
    
    table.add_row(vec![
        Cell::new("Passed").fg(Color::White),
        Cell::new(&passed.to_string()).fg(Color::Green),
    ]);
    table.add_row(vec![
        Cell::new("Failed").fg(Color::White),
        Cell::new(&failed.to_string()).fg(if failed > 0 { Color::Red } else { Color::Green }),
    ]);
    table.add_row(vec![
        Cell::new("Skipped").fg(Color::White),
        Cell::new(&skipped.to_string()).fg(Color::Yellow),
    ]);
    table.add_row(vec![
        Cell::new("Total").fg(Color::White),
        Cell::new(&(passed + failed + skipped).to_string()).fg(Color::Cyan),
    ]);
    
    println!("{table}");
    
    if failed > 0 {
        println!();
        println!("{}", "Failed Tests:".bright_red().bold());
        for result in &results {
            if !result.passed {
                println!("   - {}: {}", result.name.red(), result.actual.yellow());
            }
        }
        std::process::exit(1);
    } else {
        println!();
        println!("{}", "All tests passed!".bright_green().bold());
    }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args: Vec<String> = std::env::args().collect();

    if args.len() < 2 {
        eprintln!("Usage: ttvm [--debug] [--optimize] [--gc <type>] [--gc-debug] [--gc-stats] [--run-tests] [--no-table] [--trace] [--profile] [--no-smp] [--trace-procs] [--profile-procs] <program.ttvm|program.ttb>");
        eprintln!("       ttvm compile <input.ttvm> <output.ttb>");
        eprintln!("       ttvm compile-lisp <input.lisp> <output.ttvm>");
        eprintln!("       ttvm optimize <input.ttvm> <output.ttvm>");
        eprintln!("       ttvm test-all                                    # Run all examples and tests");
        eprintln!("       ttvm test-concurrency                           # Run concurrency tests");
        eprintln!("       ttvm test-multithreaded                         # Run multi-threaded scheduler tests");
        eprintln!("       ttvm test-message-passing                       # Run message passing tests");
        eprintln!("       ttvm test-process-spawning                      # Run process spawning tests");
        eprintln!("       ttvm test-register-whereis                      # Run REGISTER/WHEREIS tests");
        eprintln!("       ttvm test-yield-comprehensive                   # Run comprehensive YIELD tests");
        eprintln!("       ttvm test-spawn-comprehensive                   # Run comprehensive SPAWN tests");
        eprintln!("       ttvm test-send-receive-comprehensive            # Run comprehensive SEND/RECEIVE tests");
        eprintln!("       ttvm test-concurrency-bytecode                  # Run concurrency bytecode compilation tests");
        eprintln!("       ttvm test-smp-concurrency                       # Run SMP scheduler concurrency tests");
        eprintln!("       ttvm test-coffee-shop                           # Run coffee shop message passing demo");
        eprintln!("       ttvm test-supervisor-tree                       # Run supervisor tree tests");
        eprintln!("       ttvm test-selective-receive                     # Run selective receive tests");
        eprintln!("       ttvm test-trap-exit                             # Run trap_exit tests");
        eprintln!("       ttvm test-process-registry                      # Run process registry cleanup tests");
        eprintln!("");
        eprintln!("GC Types: mark-sweep (default), no-gc");
        eprintln!("SMP Scheduler: Enabled by default with all CPU cores. Use --no-smp for single-threaded mode.");
        eprintln!("Debug Output: --run-tests enables unit test tables, --gc-debug enables GC debug tables");
        eprintln!("Table Control: --no-table disables formatted output in favor of plain text");
        eprintln!("Performance: --trace enables instruction tracing, --profile enables function profiling");
        eprintln!("Concurrency: Multi-core execution enabled by default, --trace-procs enables process tracing, --profile-procs enables process profiling");
        std::process::exit(1);
    }

    let mut debug_mode = false;
    let mut optimize_mode = false;
    let mut gc_type = "mark-sweep";
    let mut gc_debug = false;
    let mut gc_stats = false;
    let mut run_tests = false;
    let mut no_table = false;
    let mut trace_enabled = false;
    let mut profile_enabled = false;
    let mut smp_enabled = true;  // SMP is now the default
    let mut trace_procs = false;
    let mut profile_procs = false;
    let mut file_index = 1;

    // Check for flags
    while file_index < args.len() && args[file_index].starts_with("--") {
        match args[file_index].as_str() {
            "--debug" => {
                debug_mode = true;
                file_index += 1;
            }
            "--optimize" => {
                optimize_mode = true;
                file_index += 1;
            }
            "--gc" => {
                if file_index + 1 >= args.len() {
                    eprintln!("--gc flag requires a garbage collector type");
                    std::process::exit(1);
                }
                gc_type = &args[file_index + 1];
                if gc_type != "mark-sweep" && gc_type != "no-gc" {
                    eprintln!("Unknown GC type: {}. Valid options: mark-sweep, no-gc", gc_type);
                    std::process::exit(1);
                }
                file_index += 2;
            }
            "--gc-debug" => {
                gc_debug = true;
                file_index += 1;
            }
            "--gc-stats" => {
                gc_stats = true;
                file_index += 1;
            }
            "--run-tests" => {
                run_tests = true;
                file_index += 1;
            }
            "--no-table" => {
                no_table = true;
                file_index += 1;
            }
            "--trace" => {
                trace_enabled = true;
                file_index += 1;
            }
            "--profile" => {
                profile_enabled = true;
                file_index += 1;
            }
            "--no-smp" => {
                smp_enabled = false;
                file_index += 1;
            }
            "--trace-procs" => {
                trace_procs = true;
                file_index += 1;
            }
            "--profile-procs" => {
                profile_procs = true;
                file_index += 1;
            }
            _ => {
                eprintln!("Unknown flag: {}", args[file_index]);
                std::process::exit(1);
            }
        }
    }

    // Handle special commands
    if file_index < args.len() {
        match args[file_index].as_str() {
            "compile" => {
                if args.len() != file_index + 3 {
                    eprintln!("Usage: tinytotvm compile <input.ttvm> <output.ttb>");
                    std::process::exit(1);
                }
                let input = &args[file_index + 1];
                let output = &args[file_index + 2];
                compiler::compile(input, output).expect("Compilation failed");
                println!("Compiled to {}", output);
                return Ok(());
            }
            "optimize" => {
                if args.len() != file_index + 3 {
                    eprintln!("Usage: tinytotvm optimize <input.ttvm> <output.ttvm>");
                    std::process::exit(1);
                }
                let input = &args[file_index + 1];
                let output = &args[file_index + 2];
                optimize_program(input, output);
                return Ok(());
            }
            "compile-lisp" => {
                if args.len() != file_index + 3 {
                    eprintln!("Usage: tinytotvm compile-lisp <input.lisp> <output.ttvm>");
                    std::process::exit(1);
                }
                let input = &args[file_index + 1];
                let output = &args[file_index + 2];
                lisp_compiler::compile_lisp(input, output);
                println!("Compiled Lisp to {}", output);
                return Ok(());
            }
            "test-all" => {
                run_comprehensive_tests();
                return Ok(());
            }
            "test-concurrency" => {
                match test_concurrency() {
                    Ok(_) => println!("All concurrency tests passed!"),
                    Err(e) => {
                        eprintln!("Concurrency tests failed: {}", e);
                        std::process::exit(1);
                    }
                }
                return Ok(());
            }
            "test-monitoring-linking" => {
                match test_process_monitoring_linking() {
                    Ok(_) => println!("All process monitoring and linking tests passed!"),
                    Err(e) => {
                        eprintln!("Process monitoring and linking tests failed: {}", e);
                        std::process::exit(1);
                    }
                }
                return Ok(());
            }
            "test-multithreaded" => {
                match test_multithreaded_scheduler() {
                    Ok(_) => println!("All multi-threaded scheduler tests passed!"),
                    Err(e) => {
                        eprintln!("Multi-threaded scheduler tests failed: {}", e);
                        std::process::exit(1);
                    }
                }
                return Ok(());
            }
            "test-message-passing" => {
                match test_message_passing() {
                    Ok(_) => println!("All message passing tests passed!"),
                    Err(e) => {
                        eprintln!("Message passing tests failed: {}", e);
                        std::process::exit(1);
                    }
                }
                return Ok(());
            }
            "test-process-spawning" => {
                match test_process_spawning() {
                    Ok(_) => println!("All process spawning tests passed!"),
                    Err(e) => {
                        eprintln!("Process spawning tests failed: {}", e);
                        std::process::exit(1);
                    }
                }
                return Ok(());
            }
            "test-register-whereis" => {
                match test_register_whereis() {
                    Ok(_) => println!("All REGISTER/WHEREIS tests passed!"),
                    Err(e) => {
                        eprintln!("REGISTER/WHEREIS tests failed: {}", e);
                        std::process::exit(1);
                    }
                }
                return Ok(());
            }
            "test-yield-comprehensive" => {
                match test_yield_comprehensive() {
                    Ok(_) => println!("All comprehensive YIELD tests passed!"),
                    Err(e) => {
                        eprintln!("Comprehensive YIELD tests failed: {}", e);
                        std::process::exit(1);
                    }
                }
                return Ok(());
            }
            "test-spawn-comprehensive" => {
                match test_spawn_comprehensive() {
                    Ok(_) => println!("All comprehensive SPAWN tests passed!"),
                    Err(e) => {
                        eprintln!("Comprehensive SPAWN tests failed: {}", e);
                        std::process::exit(1);
                    }
                }
                return Ok(());
            }
            "test-send-receive-comprehensive" => {
                match test_send_receive_comprehensive() {
                    Ok(_) => println!("All comprehensive SEND/RECEIVE tests passed!"),
                    Err(e) => {
                        eprintln!("Comprehensive SEND/RECEIVE tests failed: {}", e);
                        std::process::exit(1);
                    }
                }
                return Ok(());
            }
            "test-concurrency-bytecode" => {
                match test_concurrency_bytecode_compilation() {
                    Ok(_) => println!("All concurrency bytecode compilation tests passed!"),
                    Err(e) => {
                        eprintln!("Concurrency bytecode compilation tests failed: {}", e);
                        std::process::exit(1);
                    }
                }
                return Ok(());
            }
            "test-smp-concurrency" => {
                match test_smp_scheduler_concurrency() {
                    Ok(_) => println!("All SMP scheduler concurrency tests passed!"),
                    Err(e) => {
                        eprintln!("SMP scheduler concurrency tests failed: {}", e);
                        std::process::exit(1);
                    }
                }
                return Ok(());
            }
            "test-supervisor-tree" => {
                match test_supervisor_tree() {
                    Ok(_) => println!("All supervisor tree tests passed!"),
                    Err(e) => {
                        eprintln!("Supervisor tree tests failed: {}", e);
                        std::process::exit(1);
                    }
                }
                return Ok(());
            }
            "test-selective-receive" => {
                match test_selective_receive() {
                    Ok(_) => println!("All selective receive tests passed!"),
                    Err(e) => {
                        eprintln!("Selective receive tests failed: {}", e);
                        std::process::exit(1);
                    }
                }
                return Ok(());
            }
            "test-trap-exit" => {
                match test_trap_exit() {
                    Ok(_) => println!("All trap_exit tests passed!"),
                    Err(e) => {
                        eprintln!("Trap_exit tests failed: {}", e);
                        std::process::exit(1);
                    }
                }
                return Ok(());
            }
            "test-process-registry" => {
                match test_process_registry_cleanup() {
                    Ok(_) => println!("All process registry cleanup tests passed!"),
                    Err(e) => {
                        eprintln!("Process registry cleanup tests failed: {}", e);
                        std::process::exit(1);
                    }
                }
                return Ok(());
            }
            _ => {
                // Normal execution, continue below
            }
        }
    }

    // Create VM configuration early
    let output_mode = if no_table {
        OutputMode::Plain
    } else {
        OutputMode::PrettyTable
    };

    let config = VMConfig {
        output_mode,
        run_tests,
        gc_debug,
        gc_stats,
        debug_mode,
        optimize_mode,
        gc_type: gc_type.to_string(),
        trace_enabled,
        profile_enabled,
        smp_enabled,
        trace_procs,
        profile_procs,
    };

    // Run unit tests if requested (no program file needed)
    if config.run_tests {
        run_vm_tests(&config);
        return Ok(()); // Exit after running tests
    }

    // Check if we have a program file for normal execution
    if file_index >= args.len() {
        eprintln!("No program file specified");
        std::process::exit(1);
    }

    // Normal execution
    let mut program = if args[file_index].ends_with(".ttb") {
        bytecode::load_bytecode(&args[file_index]).expect("Failed to load bytecode")
    } else {
        match parse_program(&args[file_index]) {
            Ok(p) => p,
            Err(e) => {
                eprintln!("Parse error: {}", e);
                std::process::exit(1);
            }
        }
    };

    // Apply optimizations if requested
    if optimize_mode {
        let mut optimizer = optimizer::Optimizer::new(optimizer::OptimizationOptions::default());
        let analysis_before = optimizer.analyze_program(&program);
        
        let (optimized_program, stats) = optimizer.optimize(program);
        program = optimized_program;
        
        let analysis_after = optimizer.analyze_program(&program);
        
        println!("=== Optimization Results ===");
        println!("Instructions: {} -> {} ({})", 
            analysis_before.total_instructions, 
            analysis_after.total_instructions,
            analysis_before.total_instructions as i32 - analysis_after.total_instructions as i32);
        println!("Constants folded: {}", stats.constants_folded);
        println!("Dead instructions removed: {}", stats.dead_instructions_removed);
        println!("Tail calls optimized: {}", stats.tail_calls_optimized);
        println!("Memory operations optimized: {}", stats.memory_operations_optimized);
        println!("Peephole optimizations: {}", stats.peephole_optimizations_applied);
        println!("Constants propagated: {}", stats.constants_propagated);
        println!("Instructions combined: {}", stats.instructions_combined);
        println!("Jumps threaded: {}", stats.jumps_threaded);
        println!();
    }

    
    // Use SMP scheduler if enabled, otherwise use regular VM
    if config.smp_enabled {
        println!("Running with BEAM-style SMP scheduler...");
        println!("SMP enabled flag: {}", config.smp_enabled);
    println!("Debug: About to create SMP scheduler pool");
        
        // Create SMP scheduler pool with default number of threads (CPU cores)
        let mut scheduler_pool = SchedulerPool::new_with_default_threads();
        
        // Spawn the main process with the program
        let (main_proc_id, _main_sender) = scheduler_pool.spawn_process(program);
        println!("Main process spawned with ID: {}", main_proc_id);
        
        // Run the scheduler pool
        scheduler_pool.run()?;
        
        // Wait for schedulers to finish (run() already sets shutdown flag)
        scheduler_pool.wait_for_completion();
        
        println!("SMP scheduler shutdown complete");
        
    } else {
        // Regular single-threaded VM execution
        println!("Debug: Using regular VM (SMP disabled)");
        println!("SMP enabled flag: {}", config.smp_enabled);
        let mut vm = VM::new_with_config(program, &config.gc_type, config.debug_mode || config.gc_debug, config.gc_stats, config.trace_enabled, config.profile_enabled);
        if let Err(e) = vm.run() {
            eprintln!("VM runtime error: {}", e);
            std::process::exit(1);
        }
        
        // Output profiling results if enabled (only for regular VM mode)
        if config.profile_enabled {
            if let Some(profiler) = &vm.profiler {
                profiler.print_results(&config);
            }
        }
        
        if debug_mode {
            let (instructions, max_stack, final_stack) = vm.get_stats();
            println!("Performance stats - Instructions: {}, Max stack: {}, Final stack: {}", 
                instructions, max_stack, final_stack);
        }
        
        if gc_stats {
            let stats = vm.get_gc_stats();
            report_gc_stats(&stats, &config);
        }
    }
    Ok(())
}
